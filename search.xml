<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 多进程实现服务器并发通信</title>
      <link href="2021/04/05/socket-1/"/>
      <url>2021/04/05/socket-1/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>这里简单进行字符串的传输，并对客户端进行回射操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TCP通信服务端</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="keyword">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.108.130&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通信</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data : %d\n&quot;</span>, i++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给服务器端发送数据</span></span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket通信基础整理</title>
      <link href="2021/04/05/socket/"/>
      <url>2021/04/05/socket/</url>
      
        <content type="html"><![CDATA[<h2 id="socket简介"><a href="#socket简介" class="headerlink" title="socket简介"></a>socket简介</h2><p>套接字通信分两部分：</p><ul><li>服务器端：被动接受连接，一般不会主动发起连接。</li><li>客户端：主动向服务器发起连接 socket是一套通信的接口，<br>Linux 和 Windows 都有，但是有一些细微的差别。</li></ul><h2 id="字节序整理"><a href="#字节序整理" class="headerlink" title="字节序整理"></a>字节序整理</h2><blockquote><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。</p></blockquote><p>字节序分为大端字节序（Big-Endian）和小端字节序（Little-Endian）。大端字节序是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地<br>址处</p><h3 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h3><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。</p><p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而<br>可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。<br>BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：<br>htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">h - host 主机，主机字节序 to - 转换成什么 </span><br><span class="line">n - network 网络字节序 </span><br><span class="line">s - short unsigned short </span><br><span class="line">l - long unsigned int </span><br><span class="line"></span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt; &#x2F;&#x2F; 转换端口 </span><br><span class="line">uint16_t htons(uint16_t hostshort); &#x2F;&#x2F; 主机字节序 - 网络字节序 </span><br><span class="line">uint16_t ntohs(uint16_t netshort); &#x2F;&#x2F; 主机字节序 - 网络字节序 </span><br><span class="line">&#x2F;&#x2F; 转IP </span><br><span class="line">uint32_t htonl(uint32_t hostlong); &#x2F;&#x2F; 主机字节序 - 网络字节序 </span><br><span class="line">uint32_t ntohl(uint32_t netlong); &#x2F;&#x2F; 主机字节序 - 网络字节序</span><br></pre></td></tr></table></figure><h2 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h2><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span> </span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family; </span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br></pre></td></tr></table></figure><p>14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的<br>通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span> </span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __ss_align; </span><br><span class="line"><span class="keyword">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br></pre></td></tr></table></figure><h2 id="IP地址转换（字符串ip-整数-，主机、网络字节序的转换）"><a href="#IP地址转换（字符串ip-整数-，主机、网络字节序的转换）" class="headerlink" title="IP地址转换（字符串ip-整数 ，主机、网络字节序的转换）"></a>IP地址转换（字符串ip-整数 ，主机、网络字节序的转换）</h2><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用<br>十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录<br>日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字<br>符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>; <span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p>下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line">    af:地址族： AF_INET AF_INET6 </span><br><span class="line">src:需要转换的点分十进制的IP字符串 </span><br><span class="line">dst:转换后的结果保存在这个里面 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>; </span><br><span class="line">    af:地址族： AF_INET AF_INET6 </span><br><span class="line">src: 要转换的ip的整数的地址 </span><br><span class="line">dst: 转换成IP地址字符串保存的地方 </span><br><span class="line">size：第三个参数的大小（数组的大小） </span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure><h2 id="TCP通信的流程（程序中）"><a href="#TCP通信的流程（程序中）" class="headerlink" title="TCP通信的流程（程序中）"></a>TCP通信的流程（程序中）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TCP 通信的流程 </span><br><span class="line">&#x2F;&#x2F; 服务器端 （被动接受连接的角色） </span><br><span class="line">1. 创建一个用于监听的套接字 </span><br><span class="line">    - 监听：监听有客户端的连接 </span><br><span class="line">- 套接字：这个套接字其实就是一个文件描述符 </span><br><span class="line">2. 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息） </span><br><span class="line">    - 客户端连接服务器的时候使用的就是这个IP和端口 </span><br><span class="line">3. 设置监听，监听的fd开始工作 </span><br><span class="line">4. 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字 （fd） </span><br><span class="line">5. 通信 - 接收数据 - 发送数据 </span><br><span class="line">6. 通信结束，断开连接</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端 </span><br><span class="line">1. 创建一个用于通信的套接字（fd） </span><br><span class="line">2. 连接服务器，需要指定连接的服务器的 IP 和 端口 </span><br><span class="line">3. 连接成功了，客户端可以直接和服务器通信 - 接收数据 - 发送数据 </span><br><span class="line">4. 通信结束，断开连接</span><br></pre></td></tr></table></figure><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></span><br><span class="line"><span class="comment">// 包含了这个头文件，上面两个就可以省略 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; </span><br><span class="line">   - 功能：创建一个套接字 </span><br><span class="line">   - 参数：</span><br><span class="line">      - domain: 协议族 </span><br><span class="line">    AF_INET : ipv4 </span><br><span class="line">AF_INET6 : ipv6 </span><br><span class="line">AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">  - type: 通信过程中使用的协议类型 </span><br><span class="line">    SOCK_STREAM : 流式协议 </span><br><span class="line">SOCK_DGRAM : 报式协议 </span><br><span class="line">  - protocol : 具体的一个协议。一般写<span class="number">0</span> </span><br><span class="line">    - SOCK_STREAM : 流式协议默认使用 TCP </span><br><span class="line">- SOCK_DGRAM : 报式协议默认使用 UDP </span><br><span class="line">  - 返回值： </span><br><span class="line">    - 成功：返回文件描述符，操作的就是内核缓冲区。 </span><br><span class="line">- 失败：<span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; </span><br><span class="line"><span class="comment">// socket命 名 </span></span><br><span class="line">   - 功能：绑定，将fd 和本地的IP + 端口进行绑定 </span><br><span class="line">   - 参数： </span><br><span class="line">      - sockfd : 通过socket函数得到的文件描述符 </span><br><span class="line">  - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息 </span><br><span class="line">  - addrlen : 第二个参数结构体占的内存大小 </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// /proc/sys/net/core/somaxconn </span></span><br><span class="line">   - 功能：监听这个socket上的连接 </span><br><span class="line">   - 参数：</span><br><span class="line">      - sockfd : 通过socket()函数得到的文件描述符 </span><br><span class="line">  - backlog : 未连接的和已经连接的和的最大值， <span class="number">5</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>; </span><br><span class="line">   - 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接 </span><br><span class="line">   - 参数： </span><br><span class="line">      - sockfd : 用于监听的文件描述符 </span><br><span class="line">  - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port） </span><br><span class="line">  - addrlen : 指定第二个参数的对应的内存大小 </span><br><span class="line">   - 返回值：</span><br><span class="line">      - 成功 ：用于通信的文件描述符 </span><br><span class="line">  - <span class="number">-1</span> ： 失败 </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">   - 功能： 客户端连接服务器 </span><br><span class="line">   - 参数： </span><br><span class="line">      - sockfd : 用于通信的文件描述符 </span><br><span class="line">  - addr : 客户端要连接的服务器的地址信息 </span><br><span class="line">  - addrlen : 第二个参数的内存大小 </span><br><span class="line">   - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span> </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">// 写数据 </span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">// 读数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 多进程开发-管道通信</title>
      <link href="2021/03/29/pipe-2/"/>
      <url>2021/03/29/pipe-2/</url>
      
        <content type="html"><![CDATA[<h1 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h1><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>匿名管道只能是实现有关的进程之间的通信（父子进程等），而有名管道可以实现不同进程之间的额通讯。</p><h2 id="比如实现一个简单的进程间的聊天功能"><a href="#比如实现一个简单的进程间的聊天功能" class="headerlink" title="比如实现一个简单的进程间的聊天功能"></a>比如实现一个简单的进程间的聊天功能</h2><p>创建一个有名管道(也可以通过Linux命令mkfifo创建)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建fifo文件</span></span><br><span class="line"><span class="comment">    1.通过命令： mkfifo 名字</span></span><br><span class="line"><span class="comment">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 管道名称的路径</span></span><br><span class="line"><span class="comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span></span><br><span class="line"><span class="comment">                    是一个八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1，并设置错误号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从fifo管道中读取数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.打开管道文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接了...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向FIFO管道中写数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    有名管道的注意事项：</span></span><br><span class="line"><span class="comment">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span></span><br><span class="line"><span class="comment">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    读管道：</span></span><br><span class="line"><span class="comment">        管道中有数据，read返回实际读到的字节数</span></span><br><span class="line"><span class="comment">        管道中无数据：</span></span><br><span class="line"><span class="comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span></span><br><span class="line"><span class="comment">            写端没有全部被关闭，read阻塞等待</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    写管道：</span></span><br><span class="line"><span class="comment">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span></span><br><span class="line"><span class="comment">        管道读端没有全部关闭：</span></span><br><span class="line"><span class="comment">            管道已经满了，write会阻塞</span></span><br><span class="line"><span class="comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建管道文件</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.以只写的方式打开管道</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data : %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 多进程开发-管道</title>
      <link href="2021/03/25/pipe-1/"/>
      <url>2021/03/25/pipe-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-多进程开发-管道"><a href="#Linux-多进程开发-管道" class="headerlink" title="Linux 多进程开发-管道"></a>Linux 多进程开发-管道</h1><h2 id="管道的读写特点："><a href="#管道的读写特点：" class="headerlink" title="管道的读写特点："></a>管道的读写特点：</h2><p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</p><p>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端<br>读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</p><p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程<br>也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，<br>再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</p><p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程<br>向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</p><p>4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程<br>也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，<br>直到管道中有空位置才能再次写入数据并返回。</p><p>总结：</p><pre><code>读管道：    管道中有数据，read返回实际读到的字节数。    管道中无数据：        写端被全部关闭，read返回0（相当于读到文件的末尾）        写端没有完全关闭，read阻塞等待写管道：    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）    管道读端没有全部关闭：        管道已满，write阻塞        管道没有满，write将数据写入，并返回实际写入的字节数</code></pre><h2 id="管道通信，并设置管道非阻塞"><a href="#管道通信，并设置管道非阻塞" class="headerlink" title="管道通信，并设置管道非阻塞:"></a>管道通信，并设置管道非阻塞:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK;            // 修改flag的值</span></span><br><span class="line"><span class="comment">    fcntl(fd[0], F_SETFL, flags);   // 设置新的flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);  <span class="comment">// 获取原来的flag</span></span><br><span class="line">        flags |= O_NONBLOCK;            <span class="comment">// 修改flag的值</span></span><br><span class="line">        fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags);   <span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d\n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="keyword">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试无误.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库与静态库对比</title>
      <link href="2021/03/17/lib-2/"/>
      <url>2021/03/17/lib-2/</url>
      
        <content type="html"><![CDATA[<h1 id="动态库与静态库对比"><a href="#动态库与静态库对比" class="headerlink" title="动态库与静态库对比"></a>动态库与静态库对比</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>静态库、动态库区别来自链接阶段如何处理，链接成可执行程序。分别称为静态链接方式和动态链接方式。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p><ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>缺点：</p><ul><li>消耗系统资源，浪费内存</li><li>更新、部署、发布麻烦</li></ul><h2 id="动态库的优缺点"><a href="#动态库的优缺点" class="headerlink" title="动态库的优缺点"></a>动态库的优缺点</h2><p>优点：</p><ul><li>可以实现进程间资源共享（共享库）</li><li>更新、部署、发布简单</li><li>可以控制何时加载动态库</li></ul><p>缺点：</p><ul><li>加载速度比静态库慢</li><li>发布程序时需要提供依赖的动态库</li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库的制作</title>
      <link href="2021/03/17/lib-1/"/>
      <url>2021/03/17/lib-1/</url>
      
        <content type="html"><![CDATA[<h1 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h1><p> 命名规则：</p><ul><li>Linux: libXXX.so</li><li>windows: libXXX.dll</li></ul><p>动态库的制作：</p><ul><li><p>gcc 得到.o 文件,得到和位置无关的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  -c -fpic&#x2F;-fPIC a.c b.c</span><br></pre></td></tr></table></figure></li><li><p>gcc 得到动态库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libXXX.so</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc总结</title>
      <link href="2021/03/17/gcc-1/"/>
      <url>2021/03/17/gcc-1/</url>
      
        <content type="html"><![CDATA[<h1 id="GCC总结"><a href="#GCC总结" class="headerlink" title="GCC总结"></a>GCC总结</h1><h2 id="什么是GCC"><a href="#什么是GCC" class="headerlink" title="什么是GCC"></a>什么是GCC</h2><ul><li>GCC 原名为 GNU C语言编译器（GNU C Compiler） </li><li>GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等）</li><li>GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数<code>-std=c99</code> 启动 GCC 时，编译器支持 C99 标准。</li><li>安装命令<blockquote><p>sudo apt install gcc g++ （版本 &gt; 4.8.5） </p></blockquote></li><li>查看版本 <blockquote><p>gcc/g++ -v/–version</p></blockquote></li></ul><p><img src= "/img/loading.gif" data-lazy-src="../img/imgfile/gcc01.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 底层实现通用数组类</title>
      <link href="2021/01/25/CPP-1/"/>
      <url>2021/01/25/CPP-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-内容复习-案例：底层实现通用数组类"><a href="#C-内容复习-案例：底层实现通用数组类" class="headerlink" title="C++内容复习-案例：底层实现通用数组类"></a>C++内容复习-案例：底层实现通用数组类</h1><p>案例描述: 实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我这里使用泛式编程，一次编写的对象能够在多种数据类型中使用；除此之外，所有涉及到拷贝的操作注意要使用深拷贝，防止指针在操作中出错！！！</p><p>注意使用hpp后缀， 不然使用.h和.cpp可能出现类外实例化错误,因为这里使用到了类模板编程,在编译器看到类模板时并不会实例化类中的函数等,对于类模板函数,其实例化时机比较难把握.</p><p>MyArr.hpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">MyArray(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">MyArray(<span class="keyword">const</span> MyArray &amp; arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line"><span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[] 操作符  arr[0] ，注意：对于希望有左值可赋值的话，需要返回 T&amp;（链式）</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//这里不考虑越界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_back</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~MyArray()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"><span class="keyword">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"><span class="keyword">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">array1.Push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">array2.Pop_back();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person() &#123;&#125; </span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personArr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.Push_back(p1);</span><br><span class="line">pArray.Push_back(p2);</span><br><span class="line">pArray.Push_back(p3);</span><br><span class="line">pArray.Push_back(p4);</span><br><span class="line">pArray.Push_back(p5);</span><br><span class="line"></span><br><span class="line">printPersonArray(pArray);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试无误.</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 神经网络</title>
      <link href="2021/01/25/CPP-BPNN/"/>
      <url>2021/01/25/CPP-BPNN/</url>
      
        <content type="html"><![CDATA[<h1 id="C-实现一个三层反向传播神经网络"><a href="#C-实现一个三层反向传播神经网络" class="headerlink" title="C++实现一个三层反向传播神经网络"></a>C++实现一个三层反向传播神经网络</h1><p> 实现一个三层的神经网络，构建的神经网络结构：</p><p> 输入层有4个数据，隐藏层有4个神经元，输出层为一个结果。</p><ul><li>数据读取：使用iris数据集进行测试</li><li>数据标准化：用简单的Max-Min 标准化（另Z-scores等）</li><li>激活函数选用sigmoid</li><li>正反向传播</li><li>数据集为三分类，这里因为没有用softmax等分类器，简单用sigmoid进行三分类</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个三层BP神经网络，并训练</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Data_sample 150 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> In 4 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Out 1 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hidden_layer_neuron1  4   <span class="comment">//neurons in hidden_layer</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> w1[In][hidden_layer_neuron1];  <span class="comment">//weight</span></span><br><span class="line"><span class="keyword">double</span> w2[hidden_layer_neuron1][Out];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d_in[Data_sample][In]; </span><br><span class="line"><span class="keyword">double</span> d_out[Data_sample]; </span><br><span class="line"><span class="keyword">double</span> dv[In][hidden_layer_neuron1]; <span class="comment">//updata gradient</span></span><br><span class="line"><span class="keyword">double</span> dw[hidden_layer_neuron1][Out]; </span><br><span class="line"><span class="keyword">double</span> temp_hidden_layer1[hidden_layer_neuron1];  <span class="comment">//hidden_layer data info</span></span><br><span class="line"><span class="keyword">double</span> y_hat[Data_sample];   <span class="comment">//forward output</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> lr = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epoch = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line">FILE*  file;</span><br><span class="line"><span class="keyword">errno_t</span> err = fopen_s(&amp;file, <span class="string">&quot;Iris.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (feof(file))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fscanf_s(file, <span class="string">&quot;%lf %lf %lf %lf %lf&quot;</span>, &amp;d_in[i][<span class="number">0</span>], &amp;d_in[i][<span class="number">1</span>], &amp;d_in[i][<span class="number">2</span>], &amp;d_in[i][<span class="number">3</span>], &amp;d_out[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">printf_s(<span class="string">&quot;%d&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Normalization</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> max[In] = &#123; d_in[<span class="number">0</span>][<span class="number">0</span>] ,d_in[<span class="number">0</span>][<span class="number">1</span>] , d_in[<span class="number">0</span>][<span class="number">2</span>] , d_in[<span class="number">0</span>][<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">double</span> min[In] = &#123; d_in[<span class="number">0</span>][<span class="number">0</span>] ,d_in[<span class="number">0</span>][<span class="number">1</span>] , d_in[<span class="number">0</span>][<span class="number">2</span>] , d_in[<span class="number">0</span>][<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">double</span> sum[In] = &#123; d_in[<span class="number">0</span>][<span class="number">0</span>] ,d_in[<span class="number">0</span>][<span class="number">1</span>] , d_in[<span class="number">0</span>][<span class="number">2</span>] , d_in[<span class="number">0</span>][<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; In; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hidden_layer_neuron1; j++) &#123;</span><br><span class="line">w1[i][j] = rand() % <span class="number">1000</span> / (<span class="keyword">float</span>)<span class="number">1000</span>;   <span class="comment">//Initialize 0~1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hidden_layer_neuron1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Out; j++) &#123;</span><br><span class="line">w2[i][j] = rand() % <span class="number">1000</span> / (<span class="keyword">float</span>)<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; In; j++) &#123;</span><br><span class="line"><span class="keyword">double</span> ma = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> mi = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++) &#123;</span><br><span class="line">ma = ma &gt; d_in[i][j] ? ma : d_in[i][j];   <span class="comment">//(max-min normalization)</span></span><br><span class="line">mi = mi &lt; d_in[i][j] ? mi : d_in[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++) &#123;</span><br><span class="line">d_in[i][j] = (d_in[i][j] - mi) / (ma - mi);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; In; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hidden_layer_neuron1; j++) dv[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hidden_layer_neuron1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Out; j++) dw[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++) &#123;</span><br><span class="line">d_out[i] = (d_out[i] - <span class="number">0</span>) / <span class="number">2</span>;    <span class="comment">//three kind of label(use sigmoid so convert to (0, 0.5, 1))</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Forward</span><span class="params">(<span class="keyword">int</span> test_sample)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hidden_layer_neuron1; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; In; ++j)</span><br><span class="line">&#123;</span><br><span class="line">sum += w1[j][i] * d_in[test_sample][j];</span><br><span class="line">&#125;</span><br><span class="line">temp_hidden_layer1[i] = <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">exp</span>(-sum));  <span class="comment">//sigmoid</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Out; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hidden_layer_neuron1; ++j)</span><br><span class="line">sum += w2[j][i] * temp_hidden_layer1[j];</span><br><span class="line">y_hat[test_sample] = <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">exp</span>(-sum));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Backward</span><span class="params">(<span class="keyword">int</span> test_sample)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line"><span class="keyword">double</span> e;</span><br><span class="line"><span class="keyword">double</span> t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hidden_layer_neuron1; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Out; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp = y_hat[test_sample] * (y_hat[test_sample] - <span class="number">1</span>) * (y_hat[test_sample] - d_out[test_sample]);</span><br><span class="line">dw[i][j] = lr * temp * temp_hidden_layer1[i];</span><br><span class="line">t += temp * w2[i][j];</span><br><span class="line">w2[i][j] += dw[i][j];</span><br><span class="line">&#125;</span><br><span class="line">e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; In; j++)</span><br><span class="line">&#123;</span><br><span class="line">e = temp_hidden_layer1[i] * (<span class="number">1</span> - temp_hidden_layer1[i]) * t;</span><br><span class="line">dv[j][i] = lr * e * d_in[test_sample][j];</span><br><span class="line">w1[j][i] += dv[j][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrainNetwork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (e &lt; epoch)&#123;</span><br><span class="line">   error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Data_sample; j++)</span><br><span class="line">&#123;</span><br><span class="line">Forward(j);</span><br><span class="line">error +=(<span class="built_in">abs</span>(y_hat[j] - d_out[j]));</span><br><span class="line">Backward(j);</span><br><span class="line">&#125;</span><br><span class="line">error /= <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">if</span>(e % <span class="number">1000</span> == <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;error:%lf round:%d\n&quot;</span>, error, e);</span><br><span class="line">e++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line">ReadData();     <span class="comment">//read data set</span></span><br><span class="line">Init_Normalization(); </span><br><span class="line">TrainNetwork();</span><br><span class="line"><span class="comment">//test();</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;训练结果(真实输出：label)：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++) <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt; y_hat[i] &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; d_out[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果准确率达到85%以上，训练2000次左右基本能达到最大正确率，怎加epoch数量改变不明显，网络还需要优化。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 复习_1</title>
      <link href="2021/01/04/pytorch-1/"/>
      <url>2021/01/04/pytorch-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy和Tensor之间的转化"><a href="#Numpy和Tensor之间的转化" class="headerlink" title="Numpy和Tensor之间的转化"></a>Numpy和Tensor之间的转化</h1><hr><p>在Torch Tensor和NumPy array之间相互转化非常容易。</p><p>Torch Tensor和NumPy array会共享内存，所以改变其中一项也会改变另一项。</p><p>把Torch Tensor转变成NumPy Array</p><p>所有CPU上的Tensor都支持转成numpy或者从numpy转成Tensor。</p><h2 id="CUDA-Tensors"><a href="#CUDA-Tensors" class="headerlink" title="CUDA Tensors"></a>CUDA Tensors</h2><p>使用<code>.to</code>方法，Tensor可以被移动到别的device上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cuda可用时，使用GPU进行训练</span><br><span class="line">if torch.cuda.is_available():</span><br><span class="line">    device &#x3D; torch.device(&quot;cuda&quot;)          # a CUDA device object</span><br><span class="line">    y &#x3D; torch.ones_like(x, device&#x3D;device)  # directly create a tensor on GPU</span><br><span class="line">    x &#x3D; x.to(device)                       # or just use strings &#96;&#96;.to(&quot;cuda&quot;)&#96;&#96;</span><br><span class="line">    z &#x3D; x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(&quot;cpu&quot;, torch.double))       # &#96;&#96;.to&#96;&#96; can also change dtype together!</span><br></pre></td></tr></table></figure><h1 id="用numpy实现两层神经网络"><a href="#用numpy实现两层神经网络" class="headerlink" title="用numpy实现两层神经网络"></a>用numpy实现两层神经网络</h1><hr><p>一个全连接ReLU神经网络，一个隐藏层，没有bias。用来从x预测y，使用L2 Loss。</p><p>这一实现完全使用numpy来计算前向神经网络，loss，和反向传播,纯粹手撸神经网络代码，复习一下流程和后向传播的求梯度过程。</p><p>numpy ndarray是一个普通的n维array。它不知道任何关于深度学习或者梯度(gradient)的知识，也不知道计算图(computation graph)，只是一种用来计算数学运算的数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># N is batch size; D_in is input dimension;</span><br><span class="line"># H is hidden dimension; D_out is output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># Create random input and output data</span><br><span class="line">x &#x3D; np.random.randn(N, D_in)</span><br><span class="line">y &#x3D; np.random.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"># Randomly initialize weights</span><br><span class="line">w1 &#x3D; np.random.randn(D_in, H)</span><br><span class="line">w2 &#x3D; np.random.randn(H, D_out)</span><br><span class="line"></span><br><span class="line">learning_rate &#x3D; 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">    # Forward pass: compute predicted y</span><br><span class="line">    h &#x3D; x.dot(w1)</span><br><span class="line">    h_relu &#x3D; np.maximum(h, 0)</span><br><span class="line">    y_pred &#x3D; h_relu.dot(w2)</span><br><span class="line"></span><br><span class="line">    # Compute and print loss</span><br><span class="line">    loss &#x3D; np.square(y_pred - y).sum()</span><br><span class="line">    print(t, loss)</span><br><span class="line"></span><br><span class="line">    # Backprop to compute gradients of w1 and w2 with respect to loss</span><br><span class="line">    </span><br><span class="line">    # loss &#x3D; (y_pred - y) ** 2</span><br><span class="line">    grad_y_pred &#x3D; 2.0 * (y_pred - y)</span><br><span class="line">    # </span><br><span class="line">    grad_w2 &#x3D; h_relu.T.dot(grad_y_pred)</span><br><span class="line">    grad_h_relu &#x3D; grad_y_pred.dot(w2.T)</span><br><span class="line">    grad_h &#x3D; grad_h_relu.copy()</span><br><span class="line">    grad_h[h &lt; 0] &#x3D; 0</span><br><span class="line">    grad_w1 &#x3D; x.T.dot(grad_h)</span><br><span class="line"></span><br><span class="line">    # Update weights</span><br><span class="line">    w1 -&#x3D; learning_rate * grad_w1</span><br><span class="line">    w2 -&#x3D; learning_rate * grad_w2</span><br></pre></td></tr></table></figure><h2 id="PyTorch-Tensor和autograd"><a href="#PyTorch-Tensor和autograd" class="headerlink" title="PyTorch: Tensor和autograd"></a>PyTorch: Tensor和autograd</h2><hr><p>PyTorch的一个重要功能就是autograd，也就是说只要定义了forward pass(前向神经网络)，计算了loss之后，PyTorch可以自动求导计算模型所有参数的梯度。</p><p>一个PyTorch的Tensor表示计算图中的一个节点。如果<code>x</code>是一个Tensor并且<code>x.requires_grad=True</code>那么<code>x.grad</code>是另一个储存着<code>x</code>当前梯度(相对于一个scalar，常常是loss)的向量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">dtype &#x3D; torch.float</span><br><span class="line">device &#x3D; torch.device(&quot;cpu&quot;)</span><br><span class="line"># device &#x3D; torch.device(&quot;cuda:0&quot;) # Uncomment this to run on GPU</span><br><span class="line"></span><br><span class="line"># N 是 batch size; D_in 是 input dimension;</span><br><span class="line"># H 是 hidden dimension; D_out 是 output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># 创建随机的Tensor来保存输入和输出</span><br><span class="line"># 设定requires_grad&#x3D;False表示在反向传播的时候我们不需要计算gradient</span><br><span class="line">x &#x3D; torch.randn(N, D_in, device&#x3D;device, dtype&#x3D;dtype)</span><br><span class="line">y &#x3D; torch.randn(N, D_out, device&#x3D;device, dtype&#x3D;dtype)</span><br><span class="line"></span><br><span class="line"># 创建随机的Tensor和权重。</span><br><span class="line"># 设置requires_grad&#x3D;True表示我们希望反向传播的时候计算Tensor的gradient</span><br><span class="line">w1 &#x3D; torch.randn(D_in, H, device&#x3D;device, dtype&#x3D;dtype, requires_grad&#x3D;True)</span><br><span class="line">w2 &#x3D; torch.randn(H, D_out, device&#x3D;device, dtype&#x3D;dtype, requires_grad&#x3D;True)</span><br><span class="line"></span><br><span class="line">learning_rate &#x3D; 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">    # 前向传播:通过Tensor预测y；这个和普通的神经网络的前向传播没有任何不同，</span><br><span class="line">    # 但是我们不需要保存网络的中间运算结果，因为我们不需要手动计算反向传播。</span><br><span class="line">    y_pred &#x3D; x.mm(w1).clamp(min&#x3D;0).mm(w2)</span><br><span class="line"></span><br><span class="line">    # 通过前向传播计算loss</span><br><span class="line">    # loss是一个形状为(1，)的Tensor</span><br><span class="line">    # loss.item()可以给我们返回一个loss的scalar</span><br><span class="line">    loss &#x3D; (y_pred - y).pow(2).sum()</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    # PyTorch给我们提供了autograd的方法做反向传播。如果一个Tensor的requires_grad&#x3D;True，</span><br><span class="line">    # backward会自动计算loss相对于每个Tensor的gradient。在backward之后，</span><br><span class="line">    # w1.grad和w2.grad会包含两个loss相对于两个Tensor的gradient信息。</span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    # 我们可以手动做gradient descent(后面我们会介绍自动的方法)。</span><br><span class="line">    # 用torch.no_grad()包含以下statements，因为w1和w2都是requires_grad&#x3D;True，</span><br><span class="line">    # 但是在更新weights之后我们并不需要再做autograd。</span><br><span class="line">    # 另一种方法是在weight.data和weight.grad.data上做操作，这样就不会对grad产生影响。</span><br><span class="line">    # tensor.data会我们一个tensor，这个tensor和原来的tensor指向相同的内存空间，</span><br><span class="line">    # 但是不会记录计算图的历史。</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        w1 -&#x3D; learning_rate * w1.grad</span><br><span class="line">        w2 -&#x3D; learning_rate * w2.grad</span><br><span class="line"></span><br><span class="line">        # Manually zero the gradients after updating weights</span><br><span class="line">        w1.grad.zero_()</span><br><span class="line">        w2.grad.zero_()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PyTorch-nn-一般最常使用nn和optimizer构建"><a href="#PyTorch-nn-一般最常使用nn和optimizer构建" class="headerlink" title="PyTorch: nn 一般最常使用nn和optimizer构建"></a>PyTorch: nn 一般最常使用nn和optimizer构建</h2><hr><p>这次我们使用PyTorch中nn这个库来构建网络。<br>用PyTorch autograd来构建计算图和计算gradients，<br>然后PyTorch会帮我们自动计算gradient。</p><p>另外这一次我们不再手动更新模型的weights,而是使用optim这个包来帮助我们更新参数。<br>optim这个package提供了各种不同的模型优化方法，包括SGD+momentum, RMSProp, Adam等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line"># N is batch size; D_in is input dimension;</span><br><span class="line"># H is hidden dimension; D_out is output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># Create random Tensors to hold inputs and outputs</span><br><span class="line">x &#x3D; torch.randn(N, D_in)</span><br><span class="line">y &#x3D; torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"># Use the nn package to define our model and loss function.</span><br><span class="line">model &#x3D; torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(D_in, H),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(H, D_out),</span><br><span class="line">)</span><br><span class="line">loss_fn &#x3D; torch.nn.MSELoss(reduction&#x3D;&#39;sum&#39;)</span><br><span class="line"></span><br><span class="line"># Use the optim package to define an Optimizer that will update the weights of</span><br><span class="line"># the model for us. Here we will use Adam; the optim package contains many other</span><br><span class="line"># optimization algoriths. The first argument to the Adam constructor tells the</span><br><span class="line"># optimizer which Tensors it should update.</span><br><span class="line">learning_rate &#x3D; 1e-4</span><br><span class="line">optimizer &#x3D; torch.optim.Adam(model.parameters(), lr&#x3D;learning_rate)</span><br><span class="line">for t in range(500):</span><br><span class="line">    # Forward pass: compute predicted y by passing x to the model.</span><br><span class="line">    y_pred &#x3D; model(x)</span><br><span class="line"></span><br><span class="line">    # Compute and print loss.</span><br><span class="line">    loss &#x3D; loss_fn(y_pred, y)</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    # Before the backward pass, use the optimizer object to zero all of the</span><br><span class="line">    # gradients for the variables it will update (which are the learnable</span><br><span class="line">    # weights of the model). This is because by default, gradients are</span><br><span class="line">    # accumulated in buffers( i.e, not overwritten) whenever .backward()</span><br><span class="line">    # is called. Checkout docs of torch.autograd.backward for more details.</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    # Backward pass: compute gradient of the loss with respect to model</span><br><span class="line">    # parameters</span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    # Calling the step function on an Optimizer makes an update to its</span><br><span class="line">    # parameters</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><h2 id="PyTorch-自定义-nn-Modules"><a href="#PyTorch-自定义-nn-Modules" class="headerlink" title="PyTorch: 自定义 nn Modules"></a>PyTorch: 自定义 nn Modules</h2><hr><p>我们可以定义一个模型，这个模型继承自nn.Module类。如果需要定义一个比Sequential模型更加复杂的模型，就需要定义nn.Module模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">class TwoLayerNet(torch.nn.Module):</span><br><span class="line">    def __init__(self, D_in, H, D_out):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        In the constructor we instantiate two nn.Linear modules and assign them as</span><br><span class="line">        member variables.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        super(TwoLayerNet, self).__init__()</span><br><span class="line">        self.linear1 &#x3D; torch.nn.Linear(D_in, H)</span><br><span class="line">        self.linear2 &#x3D; torch.nn.Linear(H, D_out)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        In the forward function we accept a Tensor of input data and we must return</span><br><span class="line">        a Tensor of output data. We can use Modules defined in the constructor as</span><br><span class="line">        well as arbitrary operators on Tensors.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        h_relu &#x3D; self.linear1(x).clamp(min&#x3D;0)</span><br><span class="line">        y_pred &#x3D; self.linear2(h_relu)</span><br><span class="line">        return y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # N is batch size; D_in is input dimension;</span><br><span class="line">    # H is hidden dimension; D_out is output dimension.</span><br><span class="line">    N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line">    # Create random Tensors to hold inputs and outputs</span><br><span class="line">    x &#x3D; torch.randn(N, D_in)</span><br><span class="line">    y &#x3D; torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line">    # Construct our model by instantiating the class defined above</span><br><span class="line">    model &#x3D; TwoLayerNet(D_in, H, D_out)</span><br><span class="line"></span><br><span class="line">    # Construct our loss function and an Optimizer. The call to model.parameters()</span><br><span class="line">    # in the SGD constructor will contain the learnable parameters of the two</span><br><span class="line">    # nn.Linear modules which are members of the model.</span><br><span class="line">    criterion &#x3D; torch.nn.MSELoss(reduction&#x3D;&#39;sum&#39;)</span><br><span class="line">    optimizer &#x3D; torch.optim.SGD(model.parameters(), lr&#x3D;1e-4)</span><br><span class="line">    for t in range(500):</span><br><span class="line">        # Forward pass: Compute predicted y by passing x to the model</span><br><span class="line">        y_pred &#x3D; model(x)</span><br><span class="line"></span><br><span class="line">        # Compute and print loss</span><br><span class="line">        loss &#x3D; criterion(y_pred, y)</span><br><span class="line">        print(t, loss.item())</span><br><span class="line"> </span><br><span class="line">        # Zero gradients, perform a backward pass, and update the weights.</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-PM-2.5 预测</title>
      <link href="2020/10/15/ML-1/"/>
      <url>2020/10/15/ML-1/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习练习-预测PM2-5"><a href="#机器学习练习-预测PM2-5" class="headerlink" title="机器学习练习-预测PM2.5"></a>机器学习练习-预测PM2.5</h1><a id="more"></a><h2 id="内容描述"><a href="#内容描述" class="headerlink" title="内容描述"></a>内容描述</h2><p>输入：9个小时的数据，共18项特征（AMB_TEMP, CH4, CO, NHMC, NO, NO2, NOx, O3, PM10, PM2.5, RAINFALL, RH, SO2, THC, WD_HR, WIND_DIREC, WIND_SPEED, WS_HR）</p><p>输出：第10小时的PM2.5数值</p><p>模型：线性回归</p><h2 id="数据内容说明"><a href="#数据内容说明" class="headerlink" title="数据内容说明"></a>数据内容说明</h2><p>使用了某个检测站一年的观测数据，数据中每个小时有18个观测指标，将其作为特征。将数据分为train.csv和test.csv，train.csv是该检测站每个月前20天的所有数据，test.csv是从该检测站剩余数据中取样出的部分数据。</p><ul><li>train.cv:每个月前20天的数据</li><li>test.csv：从剩下的数据中取样连续的10小时为一组，前9小时所有观测数据当做feature，第10小时的PM2.5当做answer。一共取出240组不重复的test data，请根据feature预测这240组的PM2.5</li></ul><p>train.csv:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410135501519.png"><br>test.csv:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410135530525.png"></p><p>第4列-第27列是0-23共24小时的数据。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 读入train.csv，繁体字以big5编码</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;./train.csv&#x27;</span>, encoding = <span class="string">&#x27;big5&#x27;</span>)</span><br><span class="line"><span class="comment"># 丢弃前两列，需要的是从第三列开始的数值</span></span><br><span class="line">data = data.iloc[:, <span class="number">3</span>:]</span><br><span class="line"><span class="comment"># 把降雨的NR字符变成数值0</span></span><br><span class="line">data[data == <span class="string">&#x27;NR&#x27;</span>] = <span class="number">0</span></span><br><span class="line">raw_data = data.to_numpy()</span><br></pre></td></tr></table></figure><p>载入的数据规格为：4320行，27列。</p><blockquote><p>下述代码中的.to_numpy()函数需要pandas版本&gt;=0.24.0，否则会报错</p></blockquote><p>转换成array数组后的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[&#39;14&#39; &#39;14&#39; &#39;14&#39; ... &#39;15&#39; &#39;15&#39; &#39;15&#39;]</span><br><span class="line"> [&#39;1.8&#39; &#39;1.8&#39; &#39;1.8&#39; ... &#39;1.8&#39; &#39;1.8&#39; &#39;1.8&#39;]</span><br><span class="line"> [&#39;0.51&#39; &#39;0.41&#39; &#39;0.39&#39; ... &#39;0.35&#39; &#39;0.36&#39; &#39;0.32&#39;]</span><br><span class="line"> ...</span><br><span class="line"> [&#39;36&#39; &#39;55&#39; &#39;72&#39; ... &#39;118&#39; &#39;100&#39; &#39;105&#39;]</span><br><span class="line"> [&#39;1.9&#39; &#39;2.4&#39; &#39;1.9&#39; ... &#39;1.5&#39; &#39;2&#39; &#39;2&#39;]</span><br><span class="line"> [&#39;0.7&#39; &#39;0.8&#39; &#39;1.8&#39; ... &#39;1.6&#39; &#39;1.8&#39; &#39;2&#39;]]</span><br></pre></td></tr></table></figure><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410145553875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410145603697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>4320行中，每18行（18个观测指标）是一天的数据，将18行作为一天，4320/18=240天（一年12个月，每个月20天），根据每个月将4320行×24列的数据分成12 组18 行(features) × 480 列(hours) 的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">month_data &#x3D; &#123;&#125;</span><br><span class="line">for month in range(12):</span><br><span class="line">    sample &#x3D; np.empty([18, 480])</span><br><span class="line">    for day in range(20):</span><br><span class="line">        sample[:, day * 24 : (day + 1) * 24] &#x3D; raw_data[18 * (20 * month + day) : 18 * (20 * month + day + 1), :]</span><br><span class="line">    month_data[month] &#x3D; sample</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410150256239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410150305693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>分成了12个月，每个月有18行×480列的数据。</p><p>对于每个月，每10个小时分成一组，由前9个小时的数据来预测第10个小时的PM2.5，把前9小时的数据放入x，把第10个小时的数据放入y。窗口的大小为10，从第1个小时开始向右滑动，每次滑动1小时。因此，每个月都有471组这样的数据。</p><p>把一组18×9的数据平铺成一行向量，然后放入x的一行中，每个月有471组，共有12×471组向量，因此x有12×471行，18×9列。</p><p>将预测值放入y中，y有12（月）×471（组）行，1列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; np.empty([12 * 471, 18 * 9], dtype &#x3D; float)</span><br><span class="line">y &#x3D; np.empty([12 * 471, 1], dtype &#x3D; float)</span><br><span class="line">for month in range(12):</span><br><span class="line">    for day in range(20):</span><br><span class="line">        for hour in range(24):</span><br><span class="line">            if day &#x3D;&#x3D; 19 and hour &gt; 14:</span><br><span class="line">                continue</span><br><span class="line">            x[month * 471 + day * 24 + hour, :] &#x3D; month_data[month][:,day * 24 + hour : day * 24 + hour + 9].reshape(1, -1) #vector dim:18*9 (9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9)</span><br><span class="line">            y[month * 471 + day * 24 + hour, 0] &#x3D; month_data[month][9, day * 24 + hour + 9] #value</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>输出情况为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">[[14.  14.  14.  ...  2.   2.   0.5]</span><br><span class="line"> [14.  14.  13.  ...  2.   0.5  0.3]</span><br><span class="line"> [14.  13.  12.  ...  0.5  0.3  0.8]</span><br><span class="line"> ...</span><br><span class="line"> [17.  18.  19.  ...  1.1  1.4  1.3]</span><br><span class="line"> [18.  19.  18.  ...  1.4  1.3  1.6]</span><br><span class="line"> [19.  18.  17.  ...  1.3  1.6  1.8]]</span><br><span class="line">[[30.]</span><br><span class="line"> [41.]</span><br><span class="line"> [44.]</span><br><span class="line"> ...</span><br><span class="line"> [17.]</span><br><span class="line"> [24.]</span><br><span class="line"> [29.]]</span><br></pre></td></tr></table></figure><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p> x=(x−μ)/σ :μ是x的均值，σ是x的标准差。</p><p> 通过标准化，可以：</p><ul><li>将有量纲的表达式，经过变换，化为无量纲的表达式，成为标量</li><li>使得数据更加符合独立同分布条件<blockquote><p>这个转换使得x的均值为0，标准差为1，而不是像网上说的变成(-1,1)之间的数据。从下方的out中，可以看到有部分数据是小于-1的。</p></blockquote></li></ul><p>这里每一列是一个观测指标，按列进行标准化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mean_x &#x3D; np.mean(x, axis &#x3D; 0) #18 * 9 </span><br><span class="line">std_x &#x3D; np.std(x, axis &#x3D; 0) #18 * 9 </span><br><span class="line">for i in range(len(x)): #12 * 471</span><br><span class="line">    for j in range(len(x[0])): #18 * 9 </span><br><span class="line">        if std_x[j] !&#x3D; 0:</span><br><span class="line">            x[i][j] &#x3D; (x[i][j] - mean_x[j]) &#x2F; std_x[j]</span><br><span class="line">x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([[-1.35825331, -1.35883937, -1.359222  , ...,  0.26650729,</span><br><span class="line">         0.2656797 , -1.14082131],</span><br><span class="line">       [-1.35825331, -1.35883937, -1.51819928, ...,  0.26650729,</span><br><span class="line">        -1.13963133, -1.32832904],</span><br><span class="line">       [-1.35825331, -1.51789368, -1.67717656, ..., -1.13923451,</span><br><span class="line">        -1.32700613, -0.85955971],</span><br><span class="line">       ...,</span><br><span class="line">       [-0.88092053, -0.72262212, -0.56433559, ..., -0.57693779,</span><br><span class="line">        -0.29644471, -0.39079039],</span><br><span class="line">       [-0.7218096 , -0.56356781, -0.72331287, ..., -0.29578943,</span><br><span class="line">        -0.39013211, -0.1095288 ],</span><br><span class="line">       [-0.56269867, -0.72262212, -0.88229015, ..., -0.38950555,</span><br><span class="line">        -0.10906991,  0.07797893]])</span><br></pre></td></tr></table></figure><p>把训练数据分成训练集train_set和验证集validation，其中train_set用于训练，而validation不会参与训练，仅用于验证。（在baseline中并没有用）</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164212667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164221419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164229968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>和上图不同处: 下面Loss的代码用到的是 Root Mean Square Error</p><p>因为存在常数项b，所以维度（dim）需要多加一列；eps项是极小值，避免adagrad的分母为0.</p><p>每一个维度（dim）会对应到各自的gradient和权重w，通过一次次的迭代（iter_time）学习。最终，将训练得到的模型（权重w）存储为.npy格式的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dim &#x3D; 18 * 9 + 1</span><br><span class="line">w &#x3D; np.zeros([dim, 1])</span><br><span class="line">x &#x3D; np.concatenate((np.ones([12 * 471, 1]), x), axis &#x3D; 1).astype(float)</span><br><span class="line">learning_rate &#x3D; 100</span><br><span class="line">iter_time &#x3D; 1000</span><br><span class="line">adagrad &#x3D; np.zeros([dim, 1])</span><br><span class="line">eps &#x3D; 0.0000000001</span><br><span class="line">for t in range(iter_time):</span><br><span class="line">    loss &#x3D; np.sqrt(np.sum(np.power(np.dot(x, w) - y, 2))&#x2F;471&#x2F;12)#rmse</span><br><span class="line">    if(t%100&#x3D;&#x3D;0):</span><br><span class="line">        print(str(t) + &quot;:&quot; + str(loss))</span><br><span class="line">    gradient &#x3D; 2 * np.dot(x.transpose(), np.dot(x, w) - y) #dim*1</span><br><span class="line">    adagrad +&#x3D; gradient ** 2</span><br><span class="line">    w &#x3D; w - learning_rate * gradient &#x2F; np.sqrt(adagrad + eps)</span><br><span class="line">np.save(&#39;weight.npy&#39;, w)</span><br><span class="line">w</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">0:27.071214829194115</span><br><span class="line">100:33.78905859777454</span><br><span class="line">200:19.91375129819709</span><br><span class="line">300:13.531068193689686</span><br><span class="line">400:10.645466158446165</span><br><span class="line">500:9.27735345547506</span><br><span class="line">600:8.518042045956497</span><br><span class="line">700:8.014061987588416</span><br><span class="line">800:7.636756824775686</span><br><span class="line">900:7.33656374037112</span><br><span class="line">array([[ 2.13740269e+01],</span><br><span class="line">       [ 3.58888909e+00],</span><br><span class="line">       [ 4.56386323e+00],</span><br><span class="line">       [ 2.16307023e+00],</span><br><span class="line">       [-6.58545223e+00],</span><br><span class="line">       [-3.38885580e+01],</span><br><span class="line">       [ 3.22235518e+01],</span><br><span class="line">      ...</span><br><span class="line">       [-5.57512471e-01],</span><br><span class="line">       [ 8.76239582e-02],</span><br><span class="line">       [ 3.02594902e-01],</span><br><span class="line">       [-4.23463160e-01],</span><br><span class="line">       [ 4.89922051e-01]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传测试</title>
      <link href="2020/08/01/uploadtest-1/"/>
      <url>2020/08/01/uploadtest-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>测试！测试！</p><a id="more"></a><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>测试！测试！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hexo zm站点搭建测试！</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐测试</title>
      <link href="2020/08/01/uploadtest-4/"/>
      <url>2020/08/01/uploadtest-4/</url>
      
        <content type="html"><![CDATA[<h2 id="音乐播放测试"><a href="#音乐播放测试" class="headerlink" title="音乐播放测试"></a>音乐播放测试</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1465814430&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔添加测试</title>
      <link href="2020/08/01/uploadtest-2/"/>
      <url>2020/08/01/uploadtest-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown书写测试</title>
      <link href="2020/08/01/uploadtest-3/"/>
      <url>2020/08/01/uploadtest-3/</url>
      
        <content type="html"><![CDATA[<h1 id="文章编写测试"><a href="#文章编写测试" class="headerlink" title="文章编写测试"></a>文章编写测试</h1><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>用#的个数分标题级数<br>使用标题 </p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>同段落编写时两次空格<br>再转行，不同段落空出<br>一整行</p><p>段落1</p><p>段落2</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>文字前加 &gt;</p><blockquote><p>高亮显示内容</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[网址]加（具体地址） </p><p><a href="https://www.baidu.com/">百度</a> </p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>！加[]加（） 括号中为图片地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=365079614,1609633836&fm=26&gp=0.jpg" alt="测试"></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>内容前加 *空格  </p><ul><li>列表1  </li><li>列表2</li><li>列表3<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2>在前面加数字加.空格</li></ul><ol><li>列表1</li><li>列表2</li><li>列表3 <h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2>用多于3条—来表示或者***  </li></ol><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传测试</title>
      <link href="2020/07/31/uploadtest/"/>
      <url>2020/07/31/uploadtest/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>测试！测试！</p><a id="more"></a><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>测试！测试！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hexo zm站点搭建测试！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
