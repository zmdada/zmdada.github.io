<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态库与静态库对比</title>
      <link href="2021/03/17/lib-2/"/>
      <url>2021/03/17/lib-2/</url>
      
        <content type="html"><![CDATA[<h1 id="动态库与静态库对比"><a href="#动态库与静态库对比" class="headerlink" title="动态库与静态库对比"></a>动态库与静态库对比</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>静态库、动态库区别来自链接阶段如何处理，链接成可执行程序。分别称为静态链接方式和动态链接方式。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p><ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>缺点：</p><ul><li>消耗系统资源，浪费内存</li><li>更新、部署、发布麻烦</li></ul><h2 id="动态库的优缺点"><a href="#动态库的优缺点" class="headerlink" title="动态库的优缺点"></a>动态库的优缺点</h2><p>优点：</p><ul><li>可以实现进程间资源共享（共享库）</li><li>更新、部署、发布简单</li><li>可以控制何时加载动态库</li></ul><p>缺点：</p><ul><li>加载速度比静态库慢</li><li>发布程序时需要提供依赖的动态库</li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库的制作</title>
      <link href="2021/03/17/lib-1/"/>
      <url>2021/03/17/lib-1/</url>
      
        <content type="html"><![CDATA[<h1 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h1><p> 命名规则：</p><ul><li>Linux: libXXX.so</li><li>windows: libXXX.dll</li></ul><p>动态库的制作：</p><ul><li><p>gcc 得到.o 文件,得到和位置无关的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  -c -fpic&#x2F;-fPIC a.c b.c</span><br></pre></td></tr></table></figure></li><li><p>gcc 得到动态库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libXXX.so</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc总结</title>
      <link href="2021/03/17/gcc-1/"/>
      <url>2021/03/17/gcc-1/</url>
      
        <content type="html"><![CDATA[<h1 id="GCC总结"><a href="#GCC总结" class="headerlink" title="GCC总结"></a>GCC总结</h1><h2 id="什么是GCC"><a href="#什么是GCC" class="headerlink" title="什么是GCC"></a>什么是GCC</h2><ul><li>GCC 原名为 GNU C语言编译器（GNU C Compiler） </li><li>GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等）</li><li>GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数<code>-std=c99</code> 启动 GCC 时，编译器支持 C99 标准。</li><li>安装命令<blockquote><p>sudo apt install gcc g++ （版本 &gt; 4.8.5） </p></blockquote></li><li>查看版本 <blockquote><p>gcc/g++ -v/–version</p></blockquote></li></ul><p><img src= "/img/loading.gif" data-lazy-src="../img/imgfile/gcc01.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 底层实现通用数组类</title>
      <link href="2021/01/25/CPP-1/"/>
      <url>2021/01/25/CPP-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-内容复习-案例：底层实现通用数组类"><a href="#C-内容复习-案例：底层实现通用数组类" class="headerlink" title="C++内容复习-案例：底层实现通用数组类"></a>C++内容复习-案例：底层实现通用数组类</h1><p>案例描述: 实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我这里使用泛式编程，一次编写的对象能够在多种数据类型中使用；除此之外，所有涉及到拷贝的操作注意要使用深拷贝，防止指针在操作中出错！！！</p><p>注意使用hpp后缀， 不然使用.h和.cpp可能出现类外实例化错误,因为这里使用到了类模板编程,在编译器看到类模板时并不会实例化类中的函数等,对于类模板函数,其实例化时机比较难把握.</p><p>MyArr.hpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">MyArray(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">MyArray(<span class="keyword">const</span> MyArray &amp; arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line"><span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[] 操作符  arr[0] ，注意：对于希望有左值可赋值的话，需要返回 T&amp;（链式）</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//这里不考虑越界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_back</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~MyArray()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"><span class="keyword">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"><span class="keyword">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">array1.Push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">array2.Pop_back();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person() &#123;&#125; </span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personArr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.Push_back(p1);</span><br><span class="line">pArray.Push_back(p2);</span><br><span class="line">pArray.Push_back(p3);</span><br><span class="line">pArray.Push_back(p4);</span><br><span class="line">pArray.Push_back(p5);</span><br><span class="line"></span><br><span class="line">printPersonArray(pArray);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试无误.</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 复习_1</title>
      <link href="2021/01/04/pytorch-1/"/>
      <url>2021/01/04/pytorch-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy和Tensor之间的转化"><a href="#Numpy和Tensor之间的转化" class="headerlink" title="Numpy和Tensor之间的转化"></a>Numpy和Tensor之间的转化</h1><hr><p>在Torch Tensor和NumPy array之间相互转化非常容易。</p><p>Torch Tensor和NumPy array会共享内存，所以改变其中一项也会改变另一项。</p><p>把Torch Tensor转变成NumPy Array</p><p>所有CPU上的Tensor都支持转成numpy或者从numpy转成Tensor。</p><h2 id="CUDA-Tensors"><a href="#CUDA-Tensors" class="headerlink" title="CUDA Tensors"></a>CUDA Tensors</h2><p>使用<code>.to</code>方法，Tensor可以被移动到别的device上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cuda可用时，使用GPU进行训练</span><br><span class="line">if torch.cuda.is_available():</span><br><span class="line">    device &#x3D; torch.device(&quot;cuda&quot;)          # a CUDA device object</span><br><span class="line">    y &#x3D; torch.ones_like(x, device&#x3D;device)  # directly create a tensor on GPU</span><br><span class="line">    x &#x3D; x.to(device)                       # or just use strings &#96;&#96;.to(&quot;cuda&quot;)&#96;&#96;</span><br><span class="line">    z &#x3D; x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(&quot;cpu&quot;, torch.double))       # &#96;&#96;.to&#96;&#96; can also change dtype together!</span><br></pre></td></tr></table></figure><h1 id="用numpy实现两层神经网络"><a href="#用numpy实现两层神经网络" class="headerlink" title="用numpy实现两层神经网络"></a>用numpy实现两层神经网络</h1><hr><p>一个全连接ReLU神经网络，一个隐藏层，没有bias。用来从x预测y，使用L2 Loss。</p><p>这一实现完全使用numpy来计算前向神经网络，loss，和反向传播,纯粹手撸神经网络代码，复习一下流程和后向传播的求梯度过程。</p><p>numpy ndarray是一个普通的n维array。它不知道任何关于深度学习或者梯度(gradient)的知识，也不知道计算图(computation graph)，只是一种用来计算数学运算的数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># N is batch size; D_in is input dimension;</span><br><span class="line"># H is hidden dimension; D_out is output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># Create random input and output data</span><br><span class="line">x &#x3D; np.random.randn(N, D_in)</span><br><span class="line">y &#x3D; np.random.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"># Randomly initialize weights</span><br><span class="line">w1 &#x3D; np.random.randn(D_in, H)</span><br><span class="line">w2 &#x3D; np.random.randn(H, D_out)</span><br><span class="line"></span><br><span class="line">learning_rate &#x3D; 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">    # Forward pass: compute predicted y</span><br><span class="line">    h &#x3D; x.dot(w1)</span><br><span class="line">    h_relu &#x3D; np.maximum(h, 0)</span><br><span class="line">    y_pred &#x3D; h_relu.dot(w2)</span><br><span class="line"></span><br><span class="line">    # Compute and print loss</span><br><span class="line">    loss &#x3D; np.square(y_pred - y).sum()</span><br><span class="line">    print(t, loss)</span><br><span class="line"></span><br><span class="line">    # Backprop to compute gradients of w1 and w2 with respect to loss</span><br><span class="line">    </span><br><span class="line">    # loss &#x3D; (y_pred - y) ** 2</span><br><span class="line">    grad_y_pred &#x3D; 2.0 * (y_pred - y)</span><br><span class="line">    # </span><br><span class="line">    grad_w2 &#x3D; h_relu.T.dot(grad_y_pred)</span><br><span class="line">    grad_h_relu &#x3D; grad_y_pred.dot(w2.T)</span><br><span class="line">    grad_h &#x3D; grad_h_relu.copy()</span><br><span class="line">    grad_h[h &lt; 0] &#x3D; 0</span><br><span class="line">    grad_w1 &#x3D; x.T.dot(grad_h)</span><br><span class="line"></span><br><span class="line">    # Update weights</span><br><span class="line">    w1 -&#x3D; learning_rate * grad_w1</span><br><span class="line">    w2 -&#x3D; learning_rate * grad_w2</span><br></pre></td></tr></table></figure><h2 id="PyTorch-Tensor和autograd"><a href="#PyTorch-Tensor和autograd" class="headerlink" title="PyTorch: Tensor和autograd"></a>PyTorch: Tensor和autograd</h2><hr><p>PyTorch的一个重要功能就是autograd，也就是说只要定义了forward pass(前向神经网络)，计算了loss之后，PyTorch可以自动求导计算模型所有参数的梯度。</p><p>一个PyTorch的Tensor表示计算图中的一个节点。如果<code>x</code>是一个Tensor并且<code>x.requires_grad=True</code>那么<code>x.grad</code>是另一个储存着<code>x</code>当前梯度(相对于一个scalar，常常是loss)的向量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">dtype &#x3D; torch.float</span><br><span class="line">device &#x3D; torch.device(&quot;cpu&quot;)</span><br><span class="line"># device &#x3D; torch.device(&quot;cuda:0&quot;) # Uncomment this to run on GPU</span><br><span class="line"></span><br><span class="line"># N 是 batch size; D_in 是 input dimension;</span><br><span class="line"># H 是 hidden dimension; D_out 是 output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># 创建随机的Tensor来保存输入和输出</span><br><span class="line"># 设定requires_grad&#x3D;False表示在反向传播的时候我们不需要计算gradient</span><br><span class="line">x &#x3D; torch.randn(N, D_in, device&#x3D;device, dtype&#x3D;dtype)</span><br><span class="line">y &#x3D; torch.randn(N, D_out, device&#x3D;device, dtype&#x3D;dtype)</span><br><span class="line"></span><br><span class="line"># 创建随机的Tensor和权重。</span><br><span class="line"># 设置requires_grad&#x3D;True表示我们希望反向传播的时候计算Tensor的gradient</span><br><span class="line">w1 &#x3D; torch.randn(D_in, H, device&#x3D;device, dtype&#x3D;dtype, requires_grad&#x3D;True)</span><br><span class="line">w2 &#x3D; torch.randn(H, D_out, device&#x3D;device, dtype&#x3D;dtype, requires_grad&#x3D;True)</span><br><span class="line"></span><br><span class="line">learning_rate &#x3D; 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">    # 前向传播:通过Tensor预测y；这个和普通的神经网络的前向传播没有任何不同，</span><br><span class="line">    # 但是我们不需要保存网络的中间运算结果，因为我们不需要手动计算反向传播。</span><br><span class="line">    y_pred &#x3D; x.mm(w1).clamp(min&#x3D;0).mm(w2)</span><br><span class="line"></span><br><span class="line">    # 通过前向传播计算loss</span><br><span class="line">    # loss是一个形状为(1，)的Tensor</span><br><span class="line">    # loss.item()可以给我们返回一个loss的scalar</span><br><span class="line">    loss &#x3D; (y_pred - y).pow(2).sum()</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    # PyTorch给我们提供了autograd的方法做反向传播。如果一个Tensor的requires_grad&#x3D;True，</span><br><span class="line">    # backward会自动计算loss相对于每个Tensor的gradient。在backward之后，</span><br><span class="line">    # w1.grad和w2.grad会包含两个loss相对于两个Tensor的gradient信息。</span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    # 我们可以手动做gradient descent(后面我们会介绍自动的方法)。</span><br><span class="line">    # 用torch.no_grad()包含以下statements，因为w1和w2都是requires_grad&#x3D;True，</span><br><span class="line">    # 但是在更新weights之后我们并不需要再做autograd。</span><br><span class="line">    # 另一种方法是在weight.data和weight.grad.data上做操作，这样就不会对grad产生影响。</span><br><span class="line">    # tensor.data会我们一个tensor，这个tensor和原来的tensor指向相同的内存空间，</span><br><span class="line">    # 但是不会记录计算图的历史。</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        w1 -&#x3D; learning_rate * w1.grad</span><br><span class="line">        w2 -&#x3D; learning_rate * w2.grad</span><br><span class="line"></span><br><span class="line">        # Manually zero the gradients after updating weights</span><br><span class="line">        w1.grad.zero_()</span><br><span class="line">        w2.grad.zero_()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PyTorch-nn-一般最常使用nn和optimizer构建"><a href="#PyTorch-nn-一般最常使用nn和optimizer构建" class="headerlink" title="PyTorch: nn 一般最常使用nn和optimizer构建"></a>PyTorch: nn 一般最常使用nn和optimizer构建</h2><hr><p>这次我们使用PyTorch中nn这个库来构建网络。<br>用PyTorch autograd来构建计算图和计算gradients，<br>然后PyTorch会帮我们自动计算gradient。</p><p>另外这一次我们不再手动更新模型的weights,而是使用optim这个包来帮助我们更新参数。<br>optim这个package提供了各种不同的模型优化方法，包括SGD+momentum, RMSProp, Adam等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line"># N is batch size; D_in is input dimension;</span><br><span class="line"># H is hidden dimension; D_out is output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># Create random Tensors to hold inputs and outputs</span><br><span class="line">x &#x3D; torch.randn(N, D_in)</span><br><span class="line">y &#x3D; torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"># Use the nn package to define our model and loss function.</span><br><span class="line">model &#x3D; torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(D_in, H),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(H, D_out),</span><br><span class="line">)</span><br><span class="line">loss_fn &#x3D; torch.nn.MSELoss(reduction&#x3D;&#39;sum&#39;)</span><br><span class="line"></span><br><span class="line"># Use the optim package to define an Optimizer that will update the weights of</span><br><span class="line"># the model for us. Here we will use Adam; the optim package contains many other</span><br><span class="line"># optimization algoriths. The first argument to the Adam constructor tells the</span><br><span class="line"># optimizer which Tensors it should update.</span><br><span class="line">learning_rate &#x3D; 1e-4</span><br><span class="line">optimizer &#x3D; torch.optim.Adam(model.parameters(), lr&#x3D;learning_rate)</span><br><span class="line">for t in range(500):</span><br><span class="line">    # Forward pass: compute predicted y by passing x to the model.</span><br><span class="line">    y_pred &#x3D; model(x)</span><br><span class="line"></span><br><span class="line">    # Compute and print loss.</span><br><span class="line">    loss &#x3D; loss_fn(y_pred, y)</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    # Before the backward pass, use the optimizer object to zero all of the</span><br><span class="line">    # gradients for the variables it will update (which are the learnable</span><br><span class="line">    # weights of the model). This is because by default, gradients are</span><br><span class="line">    # accumulated in buffers( i.e, not overwritten) whenever .backward()</span><br><span class="line">    # is called. Checkout docs of torch.autograd.backward for more details.</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    # Backward pass: compute gradient of the loss with respect to model</span><br><span class="line">    # parameters</span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    # Calling the step function on an Optimizer makes an update to its</span><br><span class="line">    # parameters</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><h2 id="PyTorch-自定义-nn-Modules"><a href="#PyTorch-自定义-nn-Modules" class="headerlink" title="PyTorch: 自定义 nn Modules"></a>PyTorch: 自定义 nn Modules</h2><hr><p>我们可以定义一个模型，这个模型继承自nn.Module类。如果需要定义一个比Sequential模型更加复杂的模型，就需要定义nn.Module模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">class TwoLayerNet(torch.nn.Module):</span><br><span class="line">    def __init__(self, D_in, H, D_out):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        In the constructor we instantiate two nn.Linear modules and assign them as</span><br><span class="line">        member variables.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        super(TwoLayerNet, self).__init__()</span><br><span class="line">        self.linear1 &#x3D; torch.nn.Linear(D_in, H)</span><br><span class="line">        self.linear2 &#x3D; torch.nn.Linear(H, D_out)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        In the forward function we accept a Tensor of input data and we must return</span><br><span class="line">        a Tensor of output data. We can use Modules defined in the constructor as</span><br><span class="line">        well as arbitrary operators on Tensors.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        h_relu &#x3D; self.linear1(x).clamp(min&#x3D;0)</span><br><span class="line">        y_pred &#x3D; self.linear2(h_relu)</span><br><span class="line">        return y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # N is batch size; D_in is input dimension;</span><br><span class="line">    # H is hidden dimension; D_out is output dimension.</span><br><span class="line">    N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line">    # Create random Tensors to hold inputs and outputs</span><br><span class="line">    x &#x3D; torch.randn(N, D_in)</span><br><span class="line">    y &#x3D; torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line">    # Construct our model by instantiating the class defined above</span><br><span class="line">    model &#x3D; TwoLayerNet(D_in, H, D_out)</span><br><span class="line"></span><br><span class="line">    # Construct our loss function and an Optimizer. The call to model.parameters()</span><br><span class="line">    # in the SGD constructor will contain the learnable parameters of the two</span><br><span class="line">    # nn.Linear modules which are members of the model.</span><br><span class="line">    criterion &#x3D; torch.nn.MSELoss(reduction&#x3D;&#39;sum&#39;)</span><br><span class="line">    optimizer &#x3D; torch.optim.SGD(model.parameters(), lr&#x3D;1e-4)</span><br><span class="line">    for t in range(500):</span><br><span class="line">        # Forward pass: Compute predicted y by passing x to the model</span><br><span class="line">        y_pred &#x3D; model(x)</span><br><span class="line"></span><br><span class="line">        # Compute and print loss</span><br><span class="line">        loss &#x3D; criterion(y_pred, y)</span><br><span class="line">        print(t, loss.item())</span><br><span class="line"> </span><br><span class="line">        # Zero gradients, perform a backward pass, and update the weights.</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-PM-2.5 预测</title>
      <link href="2020/10/15/ML-1/"/>
      <url>2020/10/15/ML-1/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习练习-预测PM2-5"><a href="#机器学习练习-预测PM2-5" class="headerlink" title="机器学习练习-预测PM2.5"></a>机器学习练习-预测PM2.5</h1><a id="more"></a><h2 id="内容描述"><a href="#内容描述" class="headerlink" title="内容描述"></a>内容描述</h2><p>输入：9个小时的数据，共18项特征（AMB_TEMP, CH4, CO, NHMC, NO, NO2, NOx, O3, PM10, PM2.5, RAINFALL, RH, SO2, THC, WD_HR, WIND_DIREC, WIND_SPEED, WS_HR）</p><p>输出：第10小时的PM2.5数值</p><p>模型：线性回归</p><h2 id="数据内容说明"><a href="#数据内容说明" class="headerlink" title="数据内容说明"></a>数据内容说明</h2><p>使用了某个检测站一年的观测数据，数据中每个小时有18个观测指标，将其作为特征。将数据分为train.csv和test.csv，train.csv是该检测站每个月前20天的所有数据，test.csv是从该检测站剩余数据中取样出的部分数据。</p><ul><li>train.cv:每个月前20天的数据</li><li>test.csv：从剩下的数据中取样连续的10小时为一组，前9小时所有观测数据当做feature，第10小时的PM2.5当做answer。一共取出240组不重复的test data，请根据feature预测这240组的PM2.5</li></ul><p>train.csv:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410135501519.png"><br>test.csv:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410135530525.png"></p><p>第4列-第27列是0-23共24小时的数据。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 读入train.csv，繁体字以big5编码</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;./train.csv&#x27;</span>, encoding = <span class="string">&#x27;big5&#x27;</span>)</span><br><span class="line"><span class="comment"># 丢弃前两列，需要的是从第三列开始的数值</span></span><br><span class="line">data = data.iloc[:, <span class="number">3</span>:]</span><br><span class="line"><span class="comment"># 把降雨的NR字符变成数值0</span></span><br><span class="line">data[data == <span class="string">&#x27;NR&#x27;</span>] = <span class="number">0</span></span><br><span class="line">raw_data = data.to_numpy()</span><br></pre></td></tr></table></figure><p>载入的数据规格为：4320行，27列。</p><blockquote><p>下述代码中的.to_numpy()函数需要pandas版本&gt;=0.24.0，否则会报错</p></blockquote><p>转换成array数组后的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[&#39;14&#39; &#39;14&#39; &#39;14&#39; ... &#39;15&#39; &#39;15&#39; &#39;15&#39;]</span><br><span class="line"> [&#39;1.8&#39; &#39;1.8&#39; &#39;1.8&#39; ... &#39;1.8&#39; &#39;1.8&#39; &#39;1.8&#39;]</span><br><span class="line"> [&#39;0.51&#39; &#39;0.41&#39; &#39;0.39&#39; ... &#39;0.35&#39; &#39;0.36&#39; &#39;0.32&#39;]</span><br><span class="line"> ...</span><br><span class="line"> [&#39;36&#39; &#39;55&#39; &#39;72&#39; ... &#39;118&#39; &#39;100&#39; &#39;105&#39;]</span><br><span class="line"> [&#39;1.9&#39; &#39;2.4&#39; &#39;1.9&#39; ... &#39;1.5&#39; &#39;2&#39; &#39;2&#39;]</span><br><span class="line"> [&#39;0.7&#39; &#39;0.8&#39; &#39;1.8&#39; ... &#39;1.6&#39; &#39;1.8&#39; &#39;2&#39;]]</span><br></pre></td></tr></table></figure><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410145553875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410145603697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>4320行中，每18行（18个观测指标）是一天的数据，将18行作为一天，4320/18=240天（一年12个月，每个月20天），根据每个月将4320行×24列的数据分成12 组18 行(features) × 480 列(hours) 的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">month_data &#x3D; &#123;&#125;</span><br><span class="line">for month in range(12):</span><br><span class="line">    sample &#x3D; np.empty([18, 480])</span><br><span class="line">    for day in range(20):</span><br><span class="line">        sample[:, day * 24 : (day + 1) * 24] &#x3D; raw_data[18 * (20 * month + day) : 18 * (20 * month + day + 1), :]</span><br><span class="line">    month_data[month] &#x3D; sample</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410150256239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410150305693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>分成了12个月，每个月有18行×480列的数据。</p><p>对于每个月，每10个小时分成一组，由前9个小时的数据来预测第10个小时的PM2.5，把前9小时的数据放入x，把第10个小时的数据放入y。窗口的大小为10，从第1个小时开始向右滑动，每次滑动1小时。因此，每个月都有471组这样的数据。</p><p>把一组18×9的数据平铺成一行向量，然后放入x的一行中，每个月有471组，共有12×471组向量，因此x有12×471行，18×9列。</p><p>将预测值放入y中，y有12（月）×471（组）行，1列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; np.empty([12 * 471, 18 * 9], dtype &#x3D; float)</span><br><span class="line">y &#x3D; np.empty([12 * 471, 1], dtype &#x3D; float)</span><br><span class="line">for month in range(12):</span><br><span class="line">    for day in range(20):</span><br><span class="line">        for hour in range(24):</span><br><span class="line">            if day &#x3D;&#x3D; 19 and hour &gt; 14:</span><br><span class="line">                continue</span><br><span class="line">            x[month * 471 + day * 24 + hour, :] &#x3D; month_data[month][:,day * 24 + hour : day * 24 + hour + 9].reshape(1, -1) #vector dim:18*9 (9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9)</span><br><span class="line">            y[month * 471 + day * 24 + hour, 0] &#x3D; month_data[month][9, day * 24 + hour + 9] #value</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>输出情况为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">[[14.  14.  14.  ...  2.   2.   0.5]</span><br><span class="line"> [14.  14.  13.  ...  2.   0.5  0.3]</span><br><span class="line"> [14.  13.  12.  ...  0.5  0.3  0.8]</span><br><span class="line"> ...</span><br><span class="line"> [17.  18.  19.  ...  1.1  1.4  1.3]</span><br><span class="line"> [18.  19.  18.  ...  1.4  1.3  1.6]</span><br><span class="line"> [19.  18.  17.  ...  1.3  1.6  1.8]]</span><br><span class="line">[[30.]</span><br><span class="line"> [41.]</span><br><span class="line"> [44.]</span><br><span class="line"> ...</span><br><span class="line"> [17.]</span><br><span class="line"> [24.]</span><br><span class="line"> [29.]]</span><br></pre></td></tr></table></figure><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p> x=(x−μ)/σ :μ是x的均值，σ是x的标准差。</p><p> 通过标准化，可以：</p><ul><li>将有量纲的表达式，经过变换，化为无量纲的表达式，成为标量</li><li>使得数据更加符合独立同分布条件<blockquote><p>这个转换使得x的均值为0，标准差为1，而不是像网上说的变成(-1,1)之间的数据。从下方的out中，可以看到有部分数据是小于-1的。</p></blockquote></li></ul><p>这里每一列是一个观测指标，按列进行标准化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mean_x &#x3D; np.mean(x, axis &#x3D; 0) #18 * 9 </span><br><span class="line">std_x &#x3D; np.std(x, axis &#x3D; 0) #18 * 9 </span><br><span class="line">for i in range(len(x)): #12 * 471</span><br><span class="line">    for j in range(len(x[0])): #18 * 9 </span><br><span class="line">        if std_x[j] !&#x3D; 0:</span><br><span class="line">            x[i][j] &#x3D; (x[i][j] - mean_x[j]) &#x2F; std_x[j]</span><br><span class="line">x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([[-1.35825331, -1.35883937, -1.359222  , ...,  0.26650729,</span><br><span class="line">         0.2656797 , -1.14082131],</span><br><span class="line">       [-1.35825331, -1.35883937, -1.51819928, ...,  0.26650729,</span><br><span class="line">        -1.13963133, -1.32832904],</span><br><span class="line">       [-1.35825331, -1.51789368, -1.67717656, ..., -1.13923451,</span><br><span class="line">        -1.32700613, -0.85955971],</span><br><span class="line">       ...,</span><br><span class="line">       [-0.88092053, -0.72262212, -0.56433559, ..., -0.57693779,</span><br><span class="line">        -0.29644471, -0.39079039],</span><br><span class="line">       [-0.7218096 , -0.56356781, -0.72331287, ..., -0.29578943,</span><br><span class="line">        -0.39013211, -0.1095288 ],</span><br><span class="line">       [-0.56269867, -0.72262212, -0.88229015, ..., -0.38950555,</span><br><span class="line">        -0.10906991,  0.07797893]])</span><br></pre></td></tr></table></figure><p>把训练数据分成训练集train_set和验证集validation，其中train_set用于训练，而validation不会参与训练，仅用于验证。（在baseline中并没有用）</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164212667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164221419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164229968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>和上图不同处: 下面Loss的代码用到的是 Root Mean Square Error</p><p>因为存在常数项b，所以维度（dim）需要多加一列；eps项是极小值，避免adagrad的分母为0.</p><p>每一个维度（dim）会对应到各自的gradient和权重w，通过一次次的迭代（iter_time）学习。最终，将训练得到的模型（权重w）存储为.npy格式的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dim &#x3D; 18 * 9 + 1</span><br><span class="line">w &#x3D; np.zeros([dim, 1])</span><br><span class="line">x &#x3D; np.concatenate((np.ones([12 * 471, 1]), x), axis &#x3D; 1).astype(float)</span><br><span class="line">learning_rate &#x3D; 100</span><br><span class="line">iter_time &#x3D; 1000</span><br><span class="line">adagrad &#x3D; np.zeros([dim, 1])</span><br><span class="line">eps &#x3D; 0.0000000001</span><br><span class="line">for t in range(iter_time):</span><br><span class="line">    loss &#x3D; np.sqrt(np.sum(np.power(np.dot(x, w) - y, 2))&#x2F;471&#x2F;12)#rmse</span><br><span class="line">    if(t%100&#x3D;&#x3D;0):</span><br><span class="line">        print(str(t) + &quot;:&quot; + str(loss))</span><br><span class="line">    gradient &#x3D; 2 * np.dot(x.transpose(), np.dot(x, w) - y) #dim*1</span><br><span class="line">    adagrad +&#x3D; gradient ** 2</span><br><span class="line">    w &#x3D; w - learning_rate * gradient &#x2F; np.sqrt(adagrad + eps)</span><br><span class="line">np.save(&#39;weight.npy&#39;, w)</span><br><span class="line">w</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">0:27.071214829194115</span><br><span class="line">100:33.78905859777454</span><br><span class="line">200:19.91375129819709</span><br><span class="line">300:13.531068193689686</span><br><span class="line">400:10.645466158446165</span><br><span class="line">500:9.27735345547506</span><br><span class="line">600:8.518042045956497</span><br><span class="line">700:8.014061987588416</span><br><span class="line">800:7.636756824775686</span><br><span class="line">900:7.33656374037112</span><br><span class="line">array([[ 2.13740269e+01],</span><br><span class="line">       [ 3.58888909e+00],</span><br><span class="line">       [ 4.56386323e+00],</span><br><span class="line">       [ 2.16307023e+00],</span><br><span class="line">       [-6.58545223e+00],</span><br><span class="line">       [-3.38885580e+01],</span><br><span class="line">       [ 3.22235518e+01],</span><br><span class="line">      ...</span><br><span class="line">       [-5.57512471e-01],</span><br><span class="line">       [ 8.76239582e-02],</span><br><span class="line">       [ 3.02594902e-01],</span><br><span class="line">       [-4.23463160e-01],</span><br><span class="line">       [ 4.89922051e-01]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传测试</title>
      <link href="2020/08/01/uploadtest-1/"/>
      <url>2020/08/01/uploadtest-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>测试！测试！</p><a id="more"></a><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>测试！测试！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hexo zm站点搭建测试！</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐测试</title>
      <link href="2020/08/01/uploadtest-4/"/>
      <url>2020/08/01/uploadtest-4/</url>
      
        <content type="html"><![CDATA[<h2 id="音乐播放测试"><a href="#音乐播放测试" class="headerlink" title="音乐播放测试"></a>音乐播放测试</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1465814430&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔添加测试</title>
      <link href="2020/08/01/uploadtest-2/"/>
      <url>2020/08/01/uploadtest-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown书写测试</title>
      <link href="2020/08/01/uploadtest-3/"/>
      <url>2020/08/01/uploadtest-3/</url>
      
        <content type="html"><![CDATA[<h1 id="文章编写测试"><a href="#文章编写测试" class="headerlink" title="文章编写测试"></a>文章编写测试</h1><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>用#的个数分标题级数<br>使用标题 </p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>同段落编写时两次空格<br>再转行，不同段落空出<br>一整行</p><p>段落1</p><p>段落2</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>文字前加 &gt;</p><blockquote><p>高亮显示内容</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[网址]加（具体地址） </p><p><a href="https://www.baidu.com/">百度</a> </p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>！加[]加（） 括号中为图片地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=365079614,1609633836&fm=26&gp=0.jpg" alt="测试"></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>内容前加 *空格  </p><ul><li>列表1  </li><li>列表2</li><li>列表3<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2>在前面加数字加.空格</li></ul><ol><li>列表1</li><li>列表2</li><li>列表3 <h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2>用多于3条—来表示或者***  </li></ol><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传测试</title>
      <link href="2020/07/31/uploadtest/"/>
      <url>2020/07/31/uploadtest/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>测试！测试！</p><a id="more"></a><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>测试！测试！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hexo zm站点搭建测试！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
