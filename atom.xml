<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZM的站点</title>
  
  
  <link href="http://zmdada.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://zmdada.gitee.io/"/>
  <updated>2021-03-29T02:11:43.123Z</updated>
  <id>http://zmdada.gitee.io/</id>
  
  <author>
    <name>ZMDADA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 多进程开发-管道通信</title>
    <link href="http://zmdada.gitee.io/2021/03/29/pipe-2/"/>
    <id>http://zmdada.gitee.io/2021/03/29/pipe-2/</id>
    <published>2021-03-29T02:03:25.000Z</published>
    <updated>2021-03-29T02:11:43.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h1><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>匿名管道只能是实现有关的进程之间的通信（父子进程等），而有名管道可以实现不同进程之间的额通讯。</p><h2 id="比如实现一个简单的进程间的聊天功能"><a href="#比如实现一个简单的进程间的聊天功能" class="headerlink" title="比如实现一个简单的进程间的聊天功能"></a>比如实现一个简单的进程间的聊天功能</h2><p>创建一个有名管道(也可以通过Linux命令mkfifo创建)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建fifo文件</span></span><br><span class="line"><span class="comment">    1.通过命令： mkfifo 名字</span></span><br><span class="line"><span class="comment">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 管道名称的路径</span></span><br><span class="line"><span class="comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span></span><br><span class="line"><span class="comment">                    是一个八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1，并设置错误号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从fifo管道中读取数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.打开管道文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接了...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向FIFO管道中写数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    有名管道的注意事项：</span></span><br><span class="line"><span class="comment">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span></span><br><span class="line"><span class="comment">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    读管道：</span></span><br><span class="line"><span class="comment">        管道中有数据，read返回实际读到的字节数</span></span><br><span class="line"><span class="comment">        管道中无数据：</span></span><br><span class="line"><span class="comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span></span><br><span class="line"><span class="comment">            写端没有全部被关闭，read阻塞等待</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    写管道：</span></span><br><span class="line"><span class="comment">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span></span><br><span class="line"><span class="comment">        管道读端没有全部关闭：</span></span><br><span class="line"><span class="comment">            管道已经满了，write会阻塞</span></span><br><span class="line"><span class="comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建管道文件</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.以只写的方式打开管道</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data : %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;管道通信&quot;&gt;&lt;a href=&quot;#管道通信&quot; class=&quot;headerlink&quot; title=&quot;管道通信&quot;&gt;&lt;/a&gt;管道通信&lt;/h1&gt;&lt;h2 id=&quot;有名管道&quot;&gt;&lt;a href=&quot;#有名管道&quot; class=&quot;headerlink&quot; title=&quot;有名管道&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Linux" scheme="http://zmdada.gitee.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://zmdada.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 多进程开发-管道</title>
    <link href="http://zmdada.gitee.io/2021/03/25/pipe-1/"/>
    <id>http://zmdada.gitee.io/2021/03/25/pipe-1/</id>
    <published>2021-03-25T01:05:25.000Z</published>
    <updated>2021-03-29T02:15:36.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-多进程开发-管道"><a href="#Linux-多进程开发-管道" class="headerlink" title="Linux 多进程开发-管道"></a>Linux 多进程开发-管道</h1><h2 id="管道的读写特点："><a href="#管道的读写特点：" class="headerlink" title="管道的读写特点："></a>管道的读写特点：</h2><p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</p><p>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端<br>读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</p><p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程<br>也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，<br>再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</p><p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程<br>向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</p><p>4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程<br>也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，<br>直到管道中有空位置才能再次写入数据并返回。</p><p>总结：</p><pre><code>读管道：    管道中有数据，read返回实际读到的字节数。    管道中无数据：        写端被全部关闭，read返回0（相当于读到文件的末尾）        写端没有完全关闭，read阻塞等待写管道：    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）    管道读端没有全部关闭：        管道已满，write阻塞        管道没有满，write将数据写入，并返回实际写入的字节数</code></pre><h2 id="管道通信，并设置管道非阻塞"><a href="#管道通信，并设置管道非阻塞" class="headerlink" title="管道通信，并设置管道非阻塞:"></a>管道通信，并设置管道非阻塞:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK;            // 修改flag的值</span></span><br><span class="line"><span class="comment">    fcntl(fd[0], F_SETFL, flags);   // 设置新的flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);  <span class="comment">// 获取原来的flag</span></span><br><span class="line">        flags |= O_NONBLOCK;            <span class="comment">// 修改flag的值</span></span><br><span class="line">        fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags);   <span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d\n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="keyword">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试无误.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-多进程开发-管道&quot;&gt;&lt;a href=&quot;#Linux-多进程开发-管道&quot; class=&quot;headerlink&quot; title=&quot;Linux 多进程开发-管道&quot;&gt;&lt;/a&gt;Linux 多进程开发-管道&lt;/h1&gt;&lt;h2 id=&quot;管道的读写特点：&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Linux开发" scheme="http://zmdada.gitee.io/categories/Linux%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Linux开发" scheme="http://zmdada.gitee.io/tags/Linux%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>动态库与静态库对比</title>
    <link href="http://zmdada.gitee.io/2021/03/17/lib-2/"/>
    <id>http://zmdada.gitee.io/2021/03/17/lib-2/</id>
    <published>2021-03-17T04:43:25.000Z</published>
    <updated>2021-03-17T05:46:07.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态库与静态库对比"><a href="#动态库与静态库对比" class="headerlink" title="动态库与静态库对比"></a>动态库与静态库对比</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>静态库、动态库区别来自链接阶段如何处理，链接成可执行程序。分别称为静态链接方式和动态链接方式。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p><ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>缺点：</p><ul><li>消耗系统资源，浪费内存</li><li>更新、部署、发布麻烦</li></ul><h2 id="动态库的优缺点"><a href="#动态库的优缺点" class="headerlink" title="动态库的优缺点"></a>动态库的优缺点</h2><p>优点：</p><ul><li>可以实现进程间资源共享（共享库）</li><li>更新、部署、发布简单</li><li>可以控制何时加载动态库</li></ul><p>缺点：</p><ul><li>加载速度比静态库慢</li><li>发布程序时需要提供依赖的动态库</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态库与静态库对比&quot;&gt;&lt;a href=&quot;#动态库与静态库对比&quot; class=&quot;headerlink&quot; title=&quot;动态库与静态库对比&quot;&gt;&lt;/a&gt;动态库与静态库对比&lt;/h1&gt;&lt;h2 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="CPP" scheme="http://zmdada.gitee.io/categories/CPP/"/>
    
    
    <category term="CPP" scheme="http://zmdada.gitee.io/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>动态库的制作</title>
    <link href="http://zmdada.gitee.io/2021/03/17/lib-1/"/>
    <id>http://zmdada.gitee.io/2021/03/17/lib-1/</id>
    <published>2021-03-17T02:23:25.000Z</published>
    <updated>2021-03-17T02:31:47.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h1><p> 命名规则：</p><ul><li>Linux: libXXX.so</li><li>windows: libXXX.dll</li></ul><p>动态库的制作：</p><ul><li><p>gcc 得到.o 文件,得到和位置无关的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  -c -fpic&#x2F;-fPIC a.c b.c</span><br></pre></td></tr></table></figure></li><li><p>gcc 得到动态库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libXXX.so</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态库的制作&quot;&gt;&lt;a href=&quot;#动态库的制作&quot; class=&quot;headerlink&quot; title=&quot;动态库的制作&quot;&gt;&lt;/a&gt;动态库的制作&lt;/h1&gt;&lt;p&gt; 命名规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux: libXXX.so&lt;/li&gt;
&lt;li&gt;windows:</summary>
      
    
    
    
    <category term="CPP" scheme="http://zmdada.gitee.io/categories/CPP/"/>
    
    
    <category term="CPP" scheme="http://zmdada.gitee.io/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>gcc总结</title>
    <link href="http://zmdada.gitee.io/2021/03/17/gcc-1/"/>
    <id>http://zmdada.gitee.io/2021/03/17/gcc-1/</id>
    <published>2021-03-17T01:20:25.000Z</published>
    <updated>2021-03-17T04:33:37.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCC总结"><a href="#GCC总结" class="headerlink" title="GCC总结"></a>GCC总结</h1><h2 id="什么是GCC"><a href="#什么是GCC" class="headerlink" title="什么是GCC"></a>什么是GCC</h2><ul><li>GCC 原名为 GNU C语言编译器（GNU C Compiler） </li><li>GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等）</li><li>GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数<code>-std=c99</code> 启动 GCC 时，编译器支持 C99 标准。</li><li>安装命令<blockquote><p>sudo apt install gcc g++ （版本 &gt; 4.8.5） </p></blockquote></li><li>查看版本 <blockquote><p>gcc/g++ -v/–version</p></blockquote></li></ul><p><img src= "/img/loading.gif" data-lazy-src="../img/imgfile/gcc01.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GCC总结&quot;&gt;&lt;a href=&quot;#GCC总结&quot; class=&quot;headerlink&quot; title=&quot;GCC总结&quot;&gt;&lt;/a&gt;GCC总结&lt;/h1&gt;&lt;h2 id=&quot;什么是GCC&quot;&gt;&lt;a href=&quot;#什么是GCC&quot; class=&quot;headerlink&quot; title=&quot;什</summary>
      
    
    
    
    <category term="CPP" scheme="http://zmdada.gitee.io/categories/CPP/"/>
    
    
    <category term="CPP" scheme="http://zmdada.gitee.io/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++ 底层实现通用数组类</title>
    <link href="http://zmdada.gitee.io/2021/01/25/CPP-1/"/>
    <id>http://zmdada.gitee.io/2021/01/25/CPP-1/</id>
    <published>2021-01-25T14:05:50.000Z</published>
    <updated>2021-02-02T05:01:12.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-内容复习-案例：底层实现通用数组类"><a href="#C-内容复习-案例：底层实现通用数组类" class="headerlink" title="C++内容复习-案例：底层实现通用数组类"></a>C++内容复习-案例：底层实现通用数组类</h1><p>案例描述: 实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我这里使用泛式编程，一次编写的对象能够在多种数据类型中使用；除此之外，所有涉及到拷贝的操作注意要使用深拷贝，防止指针在操作中出错！！！</p><p>注意使用hpp后缀， 不然使用.h和.cpp可能出现类外实例化错误,因为这里使用到了类模板编程,在编译器看到类模板时并不会实例化类中的函数等,对于类模板函数,其实例化时机比较难把握.</p><p>MyArr.hpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">MyArray(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">MyArray(<span class="keyword">const</span> MyArray &amp; arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line"><span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[] 操作符  arr[0] ，注意：对于希望有左值可赋值的话，需要返回 T&amp;（链式）</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//这里不考虑越界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_back</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~MyArray()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"><span class="keyword">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"><span class="keyword">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">array1.Push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">array2.Pop_back();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person() &#123;&#125; </span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personArr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.Push_back(p1);</span><br><span class="line">pArray.Push_back(p2);</span><br><span class="line">pArray.Push_back(p3);</span><br><span class="line">pArray.Push_back(p4);</span><br><span class="line">pArray.Push_back(p5);</span><br><span class="line"></span><br><span class="line">printPersonArray(pArray);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试无误.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-内容复习-案例：底层实现通用数组类&quot;&gt;&lt;a href=&quot;#C-内容复习-案例：底层实现通用数组类&quot; class=&quot;headerlink&quot; title=&quot;C++内容复习-案例：底层实现通用数组类&quot;&gt;&lt;/a&gt;C++内容复习-案例：底层实现通用数组类&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="CPP" scheme="http://zmdada.gitee.io/categories/CPP/"/>
    
    
    <category term="CPP复习" scheme="http://zmdada.gitee.io/tags/CPP%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ 神经网络</title>
    <link href="http://zmdada.gitee.io/2021/01/25/CPP-BPNN/"/>
    <id>http://zmdada.gitee.io/2021/01/25/CPP-BPNN/</id>
    <published>2021-01-25T14:05:50.000Z</published>
    <updated>2021-03-29T02:28:26.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-实现一个三层反向传播神经网络"><a href="#C-实现一个三层反向传播神经网络" class="headerlink" title="C++实现一个三层反向传播神经网络"></a>C++实现一个三层反向传播神经网络</h1><p> 实现一个三层的神经网络，构建的神经网络结构：</p><p> 输入层有4个数据，隐藏层有4个神经元，输出层为一个结果。</p><ul><li>数据读取：使用iris数据集进行测试</li><li>数据标准化：用简单的Max-Min 标准化（另Z-scores等）</li><li>激活函数选用sigmoid</li><li>正反向传播</li><li>数据集为三分类，这里因为没有用softmax等分类器，简单用sigmoid进行三分类</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个三层BP神经网络，并训练</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Data_sample 150 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> In 4 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Out 1 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hidden_layer_neuron1  4   <span class="comment">//neurons in hidden_layer</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> w1[In][hidden_layer_neuron1];  <span class="comment">//weight</span></span><br><span class="line"><span class="keyword">double</span> w2[hidden_layer_neuron1][Out];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d_in[Data_sample][In]; </span><br><span class="line"><span class="keyword">double</span> d_out[Data_sample]; </span><br><span class="line"><span class="keyword">double</span> dv[In][hidden_layer_neuron1]; <span class="comment">//updata gradient</span></span><br><span class="line"><span class="keyword">double</span> dw[hidden_layer_neuron1][Out]; </span><br><span class="line"><span class="keyword">double</span> temp_hidden_layer1[hidden_layer_neuron1];  <span class="comment">//hidden_layer data info</span></span><br><span class="line"><span class="keyword">double</span> y_hat[Data_sample];   <span class="comment">//forward output</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> lr = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epoch = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line">FILE*  file;</span><br><span class="line"><span class="keyword">errno_t</span> err = fopen_s(&amp;file, <span class="string">&quot;Iris.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (feof(file))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fscanf_s(file, <span class="string">&quot;%lf %lf %lf %lf %lf&quot;</span>, &amp;d_in[i][<span class="number">0</span>], &amp;d_in[i][<span class="number">1</span>], &amp;d_in[i][<span class="number">2</span>], &amp;d_in[i][<span class="number">3</span>], &amp;d_out[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">printf_s(<span class="string">&quot;%d&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Normalization</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> max[In] = &#123; d_in[<span class="number">0</span>][<span class="number">0</span>] ,d_in[<span class="number">0</span>][<span class="number">1</span>] , d_in[<span class="number">0</span>][<span class="number">2</span>] , d_in[<span class="number">0</span>][<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">double</span> min[In] = &#123; d_in[<span class="number">0</span>][<span class="number">0</span>] ,d_in[<span class="number">0</span>][<span class="number">1</span>] , d_in[<span class="number">0</span>][<span class="number">2</span>] , d_in[<span class="number">0</span>][<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">double</span> sum[In] = &#123; d_in[<span class="number">0</span>][<span class="number">0</span>] ,d_in[<span class="number">0</span>][<span class="number">1</span>] , d_in[<span class="number">0</span>][<span class="number">2</span>] , d_in[<span class="number">0</span>][<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; In; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hidden_layer_neuron1; j++) &#123;</span><br><span class="line">w1[i][j] = rand() % <span class="number">1000</span> / (<span class="keyword">float</span>)<span class="number">1000</span>;   <span class="comment">//Initialize 0~1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hidden_layer_neuron1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Out; j++) &#123;</span><br><span class="line">w2[i][j] = rand() % <span class="number">1000</span> / (<span class="keyword">float</span>)<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; In; j++) &#123;</span><br><span class="line"><span class="keyword">double</span> ma = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> mi = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++) &#123;</span><br><span class="line">ma = ma &gt; d_in[i][j] ? ma : d_in[i][j];   <span class="comment">//(max-min normalization)</span></span><br><span class="line">mi = mi &lt; d_in[i][j] ? mi : d_in[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++) &#123;</span><br><span class="line">d_in[i][j] = (d_in[i][j] - mi) / (ma - mi);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; In; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hidden_layer_neuron1; j++) dv[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hidden_layer_neuron1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Out; j++) dw[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++) &#123;</span><br><span class="line">d_out[i] = (d_out[i] - <span class="number">0</span>) / <span class="number">2</span>;    <span class="comment">//three kind of label(use sigmoid so convert to (0, 0.5, 1))</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Forward</span><span class="params">(<span class="keyword">int</span> test_sample)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hidden_layer_neuron1; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; In; ++j)</span><br><span class="line">&#123;</span><br><span class="line">sum += w1[j][i] * d_in[test_sample][j];</span><br><span class="line">&#125;</span><br><span class="line">temp_hidden_layer1[i] = <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">exp</span>(-sum));  <span class="comment">//sigmoid</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Out; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hidden_layer_neuron1; ++j)</span><br><span class="line">sum += w2[j][i] * temp_hidden_layer1[j];</span><br><span class="line">y_hat[test_sample] = <span class="number">1</span> / (<span class="number">1</span> + <span class="built_in">exp</span>(-sum));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Backward</span><span class="params">(<span class="keyword">int</span> test_sample)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line"><span class="keyword">double</span> e;</span><br><span class="line"><span class="keyword">double</span> t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hidden_layer_neuron1; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Out; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp = y_hat[test_sample] * (y_hat[test_sample] - <span class="number">1</span>) * (y_hat[test_sample] - d_out[test_sample]);</span><br><span class="line">dw[i][j] = lr * temp * temp_hidden_layer1[i];</span><br><span class="line">t += temp * w2[i][j];</span><br><span class="line">w2[i][j] += dw[i][j];</span><br><span class="line">&#125;</span><br><span class="line">e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; In; j++)</span><br><span class="line">&#123;</span><br><span class="line">e = temp_hidden_layer1[i] * (<span class="number">1</span> - temp_hidden_layer1[i]) * t;</span><br><span class="line">dv[j][i] = lr * e * d_in[test_sample][j];</span><br><span class="line">w1[j][i] += dv[j][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrainNetwork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (e &lt; epoch)&#123;</span><br><span class="line">   error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Data_sample; j++)</span><br><span class="line">&#123;</span><br><span class="line">Forward(j);</span><br><span class="line">error +=(<span class="built_in">abs</span>(y_hat[j] - d_out[j]));</span><br><span class="line">Backward(j);</span><br><span class="line">&#125;</span><br><span class="line">error /= <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">if</span>(e % <span class="number">1000</span> == <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;error:%lf round:%d\n&quot;</span>, error, e);</span><br><span class="line">e++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line">ReadData();     <span class="comment">//read data set</span></span><br><span class="line">Init_Normalization(); </span><br><span class="line">TrainNetwork();</span><br><span class="line"><span class="comment">//test();</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;训练结果(真实输出：label)：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Data_sample; i++) <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt; y_hat[i] &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; d_out[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果准确率达到85%以上，训练2000次左右基本能达到最大正确率，怎加epoch数量改变不明显，网络还需要优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-实现一个三层反向传播神经网络&quot;&gt;&lt;a href=&quot;#C-实现一个三层反向传播神经网络&quot; class=&quot;headerlink&quot; title=&quot;C++实现一个三层反向传播神经网络&quot;&gt;&lt;/a&gt;C++实现一个三层反向传播神经网络&lt;/h1&gt;&lt;p&gt; 实现一个三层的神经网络</summary>
      
    
    
    
    <category term="机器学习" scheme="http://zmdada.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CPP" scheme="http://zmdada.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/CPP/"/>
    
    
    <category term="机器学习" scheme="http://zmdada.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CPP" scheme="http://zmdada.gitee.io/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch 复习_1</title>
    <link href="http://zmdada.gitee.io/2021/01/04/pytorch-1/"/>
    <id>http://zmdada.gitee.io/2021/01/04/pytorch-1/</id>
    <published>2021-01-04T06:20:12.000Z</published>
    <updated>2021-01-04T08:49:54.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Numpy和Tensor之间的转化"><a href="#Numpy和Tensor之间的转化" class="headerlink" title="Numpy和Tensor之间的转化"></a>Numpy和Tensor之间的转化</h1><hr><p>在Torch Tensor和NumPy array之间相互转化非常容易。</p><p>Torch Tensor和NumPy array会共享内存，所以改变其中一项也会改变另一项。</p><p>把Torch Tensor转变成NumPy Array</p><p>所有CPU上的Tensor都支持转成numpy或者从numpy转成Tensor。</p><h2 id="CUDA-Tensors"><a href="#CUDA-Tensors" class="headerlink" title="CUDA Tensors"></a>CUDA Tensors</h2><p>使用<code>.to</code>方法，Tensor可以被移动到别的device上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cuda可用时，使用GPU进行训练</span><br><span class="line">if torch.cuda.is_available():</span><br><span class="line">    device &#x3D; torch.device(&quot;cuda&quot;)          # a CUDA device object</span><br><span class="line">    y &#x3D; torch.ones_like(x, device&#x3D;device)  # directly create a tensor on GPU</span><br><span class="line">    x &#x3D; x.to(device)                       # or just use strings &#96;&#96;.to(&quot;cuda&quot;)&#96;&#96;</span><br><span class="line">    z &#x3D; x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(&quot;cpu&quot;, torch.double))       # &#96;&#96;.to&#96;&#96; can also change dtype together!</span><br></pre></td></tr></table></figure><h1 id="用numpy实现两层神经网络"><a href="#用numpy实现两层神经网络" class="headerlink" title="用numpy实现两层神经网络"></a>用numpy实现两层神经网络</h1><hr><p>一个全连接ReLU神经网络，一个隐藏层，没有bias。用来从x预测y，使用L2 Loss。</p><p>这一实现完全使用numpy来计算前向神经网络，loss，和反向传播,纯粹手撸神经网络代码，复习一下流程和后向传播的求梯度过程。</p><p>numpy ndarray是一个普通的n维array。它不知道任何关于深度学习或者梯度(gradient)的知识，也不知道计算图(computation graph)，只是一种用来计算数学运算的数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># N is batch size; D_in is input dimension;</span><br><span class="line"># H is hidden dimension; D_out is output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># Create random input and output data</span><br><span class="line">x &#x3D; np.random.randn(N, D_in)</span><br><span class="line">y &#x3D; np.random.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"># Randomly initialize weights</span><br><span class="line">w1 &#x3D; np.random.randn(D_in, H)</span><br><span class="line">w2 &#x3D; np.random.randn(H, D_out)</span><br><span class="line"></span><br><span class="line">learning_rate &#x3D; 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">    # Forward pass: compute predicted y</span><br><span class="line">    h &#x3D; x.dot(w1)</span><br><span class="line">    h_relu &#x3D; np.maximum(h, 0)</span><br><span class="line">    y_pred &#x3D; h_relu.dot(w2)</span><br><span class="line"></span><br><span class="line">    # Compute and print loss</span><br><span class="line">    loss &#x3D; np.square(y_pred - y).sum()</span><br><span class="line">    print(t, loss)</span><br><span class="line"></span><br><span class="line">    # Backprop to compute gradients of w1 and w2 with respect to loss</span><br><span class="line">    </span><br><span class="line">    # loss &#x3D; (y_pred - y) ** 2</span><br><span class="line">    grad_y_pred &#x3D; 2.0 * (y_pred - y)</span><br><span class="line">    # </span><br><span class="line">    grad_w2 &#x3D; h_relu.T.dot(grad_y_pred)</span><br><span class="line">    grad_h_relu &#x3D; grad_y_pred.dot(w2.T)</span><br><span class="line">    grad_h &#x3D; grad_h_relu.copy()</span><br><span class="line">    grad_h[h &lt; 0] &#x3D; 0</span><br><span class="line">    grad_w1 &#x3D; x.T.dot(grad_h)</span><br><span class="line"></span><br><span class="line">    # Update weights</span><br><span class="line">    w1 -&#x3D; learning_rate * grad_w1</span><br><span class="line">    w2 -&#x3D; learning_rate * grad_w2</span><br></pre></td></tr></table></figure><h2 id="PyTorch-Tensor和autograd"><a href="#PyTorch-Tensor和autograd" class="headerlink" title="PyTorch: Tensor和autograd"></a>PyTorch: Tensor和autograd</h2><hr><p>PyTorch的一个重要功能就是autograd，也就是说只要定义了forward pass(前向神经网络)，计算了loss之后，PyTorch可以自动求导计算模型所有参数的梯度。</p><p>一个PyTorch的Tensor表示计算图中的一个节点。如果<code>x</code>是一个Tensor并且<code>x.requires_grad=True</code>那么<code>x.grad</code>是另一个储存着<code>x</code>当前梯度(相对于一个scalar，常常是loss)的向量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">dtype &#x3D; torch.float</span><br><span class="line">device &#x3D; torch.device(&quot;cpu&quot;)</span><br><span class="line"># device &#x3D; torch.device(&quot;cuda:0&quot;) # Uncomment this to run on GPU</span><br><span class="line"></span><br><span class="line"># N 是 batch size; D_in 是 input dimension;</span><br><span class="line"># H 是 hidden dimension; D_out 是 output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># 创建随机的Tensor来保存输入和输出</span><br><span class="line"># 设定requires_grad&#x3D;False表示在反向传播的时候我们不需要计算gradient</span><br><span class="line">x &#x3D; torch.randn(N, D_in, device&#x3D;device, dtype&#x3D;dtype)</span><br><span class="line">y &#x3D; torch.randn(N, D_out, device&#x3D;device, dtype&#x3D;dtype)</span><br><span class="line"></span><br><span class="line"># 创建随机的Tensor和权重。</span><br><span class="line"># 设置requires_grad&#x3D;True表示我们希望反向传播的时候计算Tensor的gradient</span><br><span class="line">w1 &#x3D; torch.randn(D_in, H, device&#x3D;device, dtype&#x3D;dtype, requires_grad&#x3D;True)</span><br><span class="line">w2 &#x3D; torch.randn(H, D_out, device&#x3D;device, dtype&#x3D;dtype, requires_grad&#x3D;True)</span><br><span class="line"></span><br><span class="line">learning_rate &#x3D; 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">    # 前向传播:通过Tensor预测y；这个和普通的神经网络的前向传播没有任何不同，</span><br><span class="line">    # 但是我们不需要保存网络的中间运算结果，因为我们不需要手动计算反向传播。</span><br><span class="line">    y_pred &#x3D; x.mm(w1).clamp(min&#x3D;0).mm(w2)</span><br><span class="line"></span><br><span class="line">    # 通过前向传播计算loss</span><br><span class="line">    # loss是一个形状为(1，)的Tensor</span><br><span class="line">    # loss.item()可以给我们返回一个loss的scalar</span><br><span class="line">    loss &#x3D; (y_pred - y).pow(2).sum()</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    # PyTorch给我们提供了autograd的方法做反向传播。如果一个Tensor的requires_grad&#x3D;True，</span><br><span class="line">    # backward会自动计算loss相对于每个Tensor的gradient。在backward之后，</span><br><span class="line">    # w1.grad和w2.grad会包含两个loss相对于两个Tensor的gradient信息。</span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    # 我们可以手动做gradient descent(后面我们会介绍自动的方法)。</span><br><span class="line">    # 用torch.no_grad()包含以下statements，因为w1和w2都是requires_grad&#x3D;True，</span><br><span class="line">    # 但是在更新weights之后我们并不需要再做autograd。</span><br><span class="line">    # 另一种方法是在weight.data和weight.grad.data上做操作，这样就不会对grad产生影响。</span><br><span class="line">    # tensor.data会我们一个tensor，这个tensor和原来的tensor指向相同的内存空间，</span><br><span class="line">    # 但是不会记录计算图的历史。</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        w1 -&#x3D; learning_rate * w1.grad</span><br><span class="line">        w2 -&#x3D; learning_rate * w2.grad</span><br><span class="line"></span><br><span class="line">        # Manually zero the gradients after updating weights</span><br><span class="line">        w1.grad.zero_()</span><br><span class="line">        w2.grad.zero_()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PyTorch-nn-一般最常使用nn和optimizer构建"><a href="#PyTorch-nn-一般最常使用nn和optimizer构建" class="headerlink" title="PyTorch: nn 一般最常使用nn和optimizer构建"></a>PyTorch: nn 一般最常使用nn和optimizer构建</h2><hr><p>这次我们使用PyTorch中nn这个库来构建网络。<br>用PyTorch autograd来构建计算图和计算gradients，<br>然后PyTorch会帮我们自动计算gradient。</p><p>另外这一次我们不再手动更新模型的weights,而是使用optim这个包来帮助我们更新参数。<br>optim这个package提供了各种不同的模型优化方法，包括SGD+momentum, RMSProp, Adam等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line"># N is batch size; D_in is input dimension;</span><br><span class="line"># H is hidden dimension; D_out is output dimension.</span><br><span class="line">N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># Create random Tensors to hold inputs and outputs</span><br><span class="line">x &#x3D; torch.randn(N, D_in)</span><br><span class="line">y &#x3D; torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"># Use the nn package to define our model and loss function.</span><br><span class="line">model &#x3D; torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(D_in, H),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(H, D_out),</span><br><span class="line">)</span><br><span class="line">loss_fn &#x3D; torch.nn.MSELoss(reduction&#x3D;&#39;sum&#39;)</span><br><span class="line"></span><br><span class="line"># Use the optim package to define an Optimizer that will update the weights of</span><br><span class="line"># the model for us. Here we will use Adam; the optim package contains many other</span><br><span class="line"># optimization algoriths. The first argument to the Adam constructor tells the</span><br><span class="line"># optimizer which Tensors it should update.</span><br><span class="line">learning_rate &#x3D; 1e-4</span><br><span class="line">optimizer &#x3D; torch.optim.Adam(model.parameters(), lr&#x3D;learning_rate)</span><br><span class="line">for t in range(500):</span><br><span class="line">    # Forward pass: compute predicted y by passing x to the model.</span><br><span class="line">    y_pred &#x3D; model(x)</span><br><span class="line"></span><br><span class="line">    # Compute and print loss.</span><br><span class="line">    loss &#x3D; loss_fn(y_pred, y)</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    # Before the backward pass, use the optimizer object to zero all of the</span><br><span class="line">    # gradients for the variables it will update (which are the learnable</span><br><span class="line">    # weights of the model). This is because by default, gradients are</span><br><span class="line">    # accumulated in buffers( i.e, not overwritten) whenever .backward()</span><br><span class="line">    # is called. Checkout docs of torch.autograd.backward for more details.</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    # Backward pass: compute gradient of the loss with respect to model</span><br><span class="line">    # parameters</span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    # Calling the step function on an Optimizer makes an update to its</span><br><span class="line">    # parameters</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><h2 id="PyTorch-自定义-nn-Modules"><a href="#PyTorch-自定义-nn-Modules" class="headerlink" title="PyTorch: 自定义 nn Modules"></a>PyTorch: 自定义 nn Modules</h2><hr><p>我们可以定义一个模型，这个模型继承自nn.Module类。如果需要定义一个比Sequential模型更加复杂的模型，就需要定义nn.Module模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">class TwoLayerNet(torch.nn.Module):</span><br><span class="line">    def __init__(self, D_in, H, D_out):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        In the constructor we instantiate two nn.Linear modules and assign them as</span><br><span class="line">        member variables.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        super(TwoLayerNet, self).__init__()</span><br><span class="line">        self.linear1 &#x3D; torch.nn.Linear(D_in, H)</span><br><span class="line">        self.linear2 &#x3D; torch.nn.Linear(H, D_out)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        In the forward function we accept a Tensor of input data and we must return</span><br><span class="line">        a Tensor of output data. We can use Modules defined in the constructor as</span><br><span class="line">        well as arbitrary operators on Tensors.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        h_relu &#x3D; self.linear1(x).clamp(min&#x3D;0)</span><br><span class="line">        y_pred &#x3D; self.linear2(h_relu)</span><br><span class="line">        return y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # N is batch size; D_in is input dimension;</span><br><span class="line">    # H is hidden dimension; D_out is output dimension.</span><br><span class="line">    N, D_in, H, D_out &#x3D; 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line">    # Create random Tensors to hold inputs and outputs</span><br><span class="line">    x &#x3D; torch.randn(N, D_in)</span><br><span class="line">    y &#x3D; torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line">    # Construct our model by instantiating the class defined above</span><br><span class="line">    model &#x3D; TwoLayerNet(D_in, H, D_out)</span><br><span class="line"></span><br><span class="line">    # Construct our loss function and an Optimizer. The call to model.parameters()</span><br><span class="line">    # in the SGD constructor will contain the learnable parameters of the two</span><br><span class="line">    # nn.Linear modules which are members of the model.</span><br><span class="line">    criterion &#x3D; torch.nn.MSELoss(reduction&#x3D;&#39;sum&#39;)</span><br><span class="line">    optimizer &#x3D; torch.optim.SGD(model.parameters(), lr&#x3D;1e-4)</span><br><span class="line">    for t in range(500):</span><br><span class="line">        # Forward pass: Compute predicted y by passing x to the model</span><br><span class="line">        y_pred &#x3D; model(x)</span><br><span class="line"></span><br><span class="line">        # Compute and print loss</span><br><span class="line">        loss &#x3D; criterion(y_pred, y)</span><br><span class="line">        print(t, loss.item())</span><br><span class="line"> </span><br><span class="line">        # Zero gradients, perform a backward pass, and update the weights.</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Numpy和Tensor之间的转化&quot;&gt;&lt;a href=&quot;#Numpy和Tensor之间的转化&quot; class=&quot;headerlink&quot; title=&quot;Numpy和Tensor之间的转化&quot;&gt;&lt;/a&gt;Numpy和Tensor之间的转化&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在Torc</summary>
      
    
    
    
    <category term="机器学习" scheme="http://zmdada.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Pytorch" scheme="http://zmdada.gitee.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-PM-2.5 预测</title>
    <link href="http://zmdada.gitee.io/2020/10/15/ML-1/"/>
    <id>http://zmdada.gitee.io/2020/10/15/ML-1/</id>
    <published>2020-10-15T12:05:50.000Z</published>
    <updated>2020-10-18T12:51:45.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习练习-预测PM2-5"><a href="#机器学习练习-预测PM2-5" class="headerlink" title="机器学习练习-预测PM2.5"></a>机器学习练习-预测PM2.5</h1><a id="more"></a><h2 id="内容描述"><a href="#内容描述" class="headerlink" title="内容描述"></a>内容描述</h2><p>输入：9个小时的数据，共18项特征（AMB_TEMP, CH4, CO, NHMC, NO, NO2, NOx, O3, PM10, PM2.5, RAINFALL, RH, SO2, THC, WD_HR, WIND_DIREC, WIND_SPEED, WS_HR）</p><p>输出：第10小时的PM2.5数值</p><p>模型：线性回归</p><h2 id="数据内容说明"><a href="#数据内容说明" class="headerlink" title="数据内容说明"></a>数据内容说明</h2><p>使用了某个检测站一年的观测数据，数据中每个小时有18个观测指标，将其作为特征。将数据分为train.csv和test.csv，train.csv是该检测站每个月前20天的所有数据，test.csv是从该检测站剩余数据中取样出的部分数据。</p><ul><li>train.cv:每个月前20天的数据</li><li>test.csv：从剩下的数据中取样连续的10小时为一组，前9小时所有观测数据当做feature，第10小时的PM2.5当做answer。一共取出240组不重复的test data，请根据feature预测这240组的PM2.5</li></ul><p>train.csv:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410135501519.png"><br>test.csv:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410135530525.png"></p><p>第4列-第27列是0-23共24小时的数据。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 读入train.csv，繁体字以big5编码</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;./train.csv&#x27;</span>, encoding = <span class="string">&#x27;big5&#x27;</span>)</span><br><span class="line"><span class="comment"># 丢弃前两列，需要的是从第三列开始的数值</span></span><br><span class="line">data = data.iloc[:, <span class="number">3</span>:]</span><br><span class="line"><span class="comment"># 把降雨的NR字符变成数值0</span></span><br><span class="line">data[data == <span class="string">&#x27;NR&#x27;</span>] = <span class="number">0</span></span><br><span class="line">raw_data = data.to_numpy()</span><br></pre></td></tr></table></figure><p>载入的数据规格为：4320行，27列。</p><blockquote><p>下述代码中的.to_numpy()函数需要pandas版本&gt;=0.24.0，否则会报错</p></blockquote><p>转换成array数组后的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[&#39;14&#39; &#39;14&#39; &#39;14&#39; ... &#39;15&#39; &#39;15&#39; &#39;15&#39;]</span><br><span class="line"> [&#39;1.8&#39; &#39;1.8&#39; &#39;1.8&#39; ... &#39;1.8&#39; &#39;1.8&#39; &#39;1.8&#39;]</span><br><span class="line"> [&#39;0.51&#39; &#39;0.41&#39; &#39;0.39&#39; ... &#39;0.35&#39; &#39;0.36&#39; &#39;0.32&#39;]</span><br><span class="line"> ...</span><br><span class="line"> [&#39;36&#39; &#39;55&#39; &#39;72&#39; ... &#39;118&#39; &#39;100&#39; &#39;105&#39;]</span><br><span class="line"> [&#39;1.9&#39; &#39;2.4&#39; &#39;1.9&#39; ... &#39;1.5&#39; &#39;2&#39; &#39;2&#39;]</span><br><span class="line"> [&#39;0.7&#39; &#39;0.8&#39; &#39;1.8&#39; ... &#39;1.6&#39; &#39;1.8&#39; &#39;2&#39;]]</span><br></pre></td></tr></table></figure><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410145553875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410145603697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>4320行中，每18行（18个观测指标）是一天的数据，将18行作为一天，4320/18=240天（一年12个月，每个月20天），根据每个月将4320行×24列的数据分成12 组18 行(features) × 480 列(hours) 的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">month_data &#x3D; &#123;&#125;</span><br><span class="line">for month in range(12):</span><br><span class="line">    sample &#x3D; np.empty([18, 480])</span><br><span class="line">    for day in range(20):</span><br><span class="line">        sample[:, day * 24 : (day + 1) * 24] &#x3D; raw_data[18 * (20 * month + day) : 18 * (20 * month + day + 1), :]</span><br><span class="line">    month_data[month] &#x3D; sample</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410150256239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410150305693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>分成了12个月，每个月有18行×480列的数据。</p><p>对于每个月，每10个小时分成一组，由前9个小时的数据来预测第10个小时的PM2.5，把前9小时的数据放入x，把第10个小时的数据放入y。窗口的大小为10，从第1个小时开始向右滑动，每次滑动1小时。因此，每个月都有471组这样的数据。</p><p>把一组18×9的数据平铺成一行向量，然后放入x的一行中，每个月有471组，共有12×471组向量，因此x有12×471行，18×9列。</p><p>将预测值放入y中，y有12（月）×471（组）行，1列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; np.empty([12 * 471, 18 * 9], dtype &#x3D; float)</span><br><span class="line">y &#x3D; np.empty([12 * 471, 1], dtype &#x3D; float)</span><br><span class="line">for month in range(12):</span><br><span class="line">    for day in range(20):</span><br><span class="line">        for hour in range(24):</span><br><span class="line">            if day &#x3D;&#x3D; 19 and hour &gt; 14:</span><br><span class="line">                continue</span><br><span class="line">            x[month * 471 + day * 24 + hour, :] &#x3D; month_data[month][:,day * 24 + hour : day * 24 + hour + 9].reshape(1, -1) #vector dim:18*9 (9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9)</span><br><span class="line">            y[month * 471 + day * 24 + hour, 0] &#x3D; month_data[month][9, day * 24 + hour + 9] #value</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>输出情况为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">[[14.  14.  14.  ...  2.   2.   0.5]</span><br><span class="line"> [14.  14.  13.  ...  2.   0.5  0.3]</span><br><span class="line"> [14.  13.  12.  ...  0.5  0.3  0.8]</span><br><span class="line"> ...</span><br><span class="line"> [17.  18.  19.  ...  1.1  1.4  1.3]</span><br><span class="line"> [18.  19.  18.  ...  1.4  1.3  1.6]</span><br><span class="line"> [19.  18.  17.  ...  1.3  1.6  1.8]]</span><br><span class="line">[[30.]</span><br><span class="line"> [41.]</span><br><span class="line"> [44.]</span><br><span class="line"> ...</span><br><span class="line"> [17.]</span><br><span class="line"> [24.]</span><br><span class="line"> [29.]]</span><br></pre></td></tr></table></figure><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p> x=(x−μ)/σ :μ是x的均值，σ是x的标准差。</p><p> 通过标准化，可以：</p><ul><li>将有量纲的表达式，经过变换，化为无量纲的表达式，成为标量</li><li>使得数据更加符合独立同分布条件<blockquote><p>这个转换使得x的均值为0，标准差为1，而不是像网上说的变成(-1,1)之间的数据。从下方的out中，可以看到有部分数据是小于-1的。</p></blockquote></li></ul><p>这里每一列是一个观测指标，按列进行标准化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mean_x &#x3D; np.mean(x, axis &#x3D; 0) #18 * 9 </span><br><span class="line">std_x &#x3D; np.std(x, axis &#x3D; 0) #18 * 9 </span><br><span class="line">for i in range(len(x)): #12 * 471</span><br><span class="line">    for j in range(len(x[0])): #18 * 9 </span><br><span class="line">        if std_x[j] !&#x3D; 0:</span><br><span class="line">            x[i][j] &#x3D; (x[i][j] - mean_x[j]) &#x2F; std_x[j]</span><br><span class="line">x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">array([[-1.35825331, -1.35883937, -1.359222  , ...,  0.26650729,</span><br><span class="line">         0.2656797 , -1.14082131],</span><br><span class="line">       [-1.35825331, -1.35883937, -1.51819928, ...,  0.26650729,</span><br><span class="line">        -1.13963133, -1.32832904],</span><br><span class="line">       [-1.35825331, -1.51789368, -1.67717656, ..., -1.13923451,</span><br><span class="line">        -1.32700613, -0.85955971],</span><br><span class="line">       ...,</span><br><span class="line">       [-0.88092053, -0.72262212, -0.56433559, ..., -0.57693779,</span><br><span class="line">        -0.29644471, -0.39079039],</span><br><span class="line">       [-0.7218096 , -0.56356781, -0.72331287, ..., -0.29578943,</span><br><span class="line">        -0.39013211, -0.1095288 ],</span><br><span class="line">       [-0.56269867, -0.72262212, -0.88229015, ..., -0.38950555,</span><br><span class="line">        -0.10906991,  0.07797893]])</span><br></pre></td></tr></table></figure><p>把训练数据分成训练集train_set和验证集validation，其中train_set用于训练，而validation不会参与训练，仅用于验证。（在baseline中并没有用）</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164212667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164221419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410164229968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZWFwb3k=,size_16,color_FFFFFF,t_70"><br>和上图不同处: 下面Loss的代码用到的是 Root Mean Square Error</p><p>因为存在常数项b，所以维度（dim）需要多加一列；eps项是极小值，避免adagrad的分母为0.</p><p>每一个维度（dim）会对应到各自的gradient和权重w，通过一次次的迭代（iter_time）学习。最终，将训练得到的模型（权重w）存储为.npy格式的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dim &#x3D; 18 * 9 + 1</span><br><span class="line">w &#x3D; np.zeros([dim, 1])</span><br><span class="line">x &#x3D; np.concatenate((np.ones([12 * 471, 1]), x), axis &#x3D; 1).astype(float)</span><br><span class="line">learning_rate &#x3D; 100</span><br><span class="line">iter_time &#x3D; 1000</span><br><span class="line">adagrad &#x3D; np.zeros([dim, 1])</span><br><span class="line">eps &#x3D; 0.0000000001</span><br><span class="line">for t in range(iter_time):</span><br><span class="line">    loss &#x3D; np.sqrt(np.sum(np.power(np.dot(x, w) - y, 2))&#x2F;471&#x2F;12)#rmse</span><br><span class="line">    if(t%100&#x3D;&#x3D;0):</span><br><span class="line">        print(str(t) + &quot;:&quot; + str(loss))</span><br><span class="line">    gradient &#x3D; 2 * np.dot(x.transpose(), np.dot(x, w) - y) #dim*1</span><br><span class="line">    adagrad +&#x3D; gradient ** 2</span><br><span class="line">    w &#x3D; w - learning_rate * gradient &#x2F; np.sqrt(adagrad + eps)</span><br><span class="line">np.save(&#39;weight.npy&#39;, w)</span><br><span class="line">w</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Out:</span><br><span class="line">0:27.071214829194115</span><br><span class="line">100:33.78905859777454</span><br><span class="line">200:19.91375129819709</span><br><span class="line">300:13.531068193689686</span><br><span class="line">400:10.645466158446165</span><br><span class="line">500:9.27735345547506</span><br><span class="line">600:8.518042045956497</span><br><span class="line">700:8.014061987588416</span><br><span class="line">800:7.636756824775686</span><br><span class="line">900:7.33656374037112</span><br><span class="line">array([[ 2.13740269e+01],</span><br><span class="line">       [ 3.58888909e+00],</span><br><span class="line">       [ 4.56386323e+00],</span><br><span class="line">       [ 2.16307023e+00],</span><br><span class="line">       [-6.58545223e+00],</span><br><span class="line">       [-3.38885580e+01],</span><br><span class="line">       [ 3.22235518e+01],</span><br><span class="line">      ...</span><br><span class="line">       [-5.57512471e-01],</span><br><span class="line">       [ 8.76239582e-02],</span><br><span class="line">       [ 3.02594902e-01],</span><br><span class="line">       [-4.23463160e-01],</span><br><span class="line">       [ 4.89922051e-01]])</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;机器学习练习-预测PM2-5&quot;&gt;&lt;a href=&quot;#机器学习练习-预测PM2-5&quot; class=&quot;headerlink&quot; title=&quot;机器学习练习-预测PM2.5&quot;&gt;&lt;/a&gt;机器学习练习-预测PM2.5&lt;/h1&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://zmdada.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="http://zmdada.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>上传测试</title>
    <link href="http://zmdada.gitee.io/2020/08/01/uploadtest-1/"/>
    <id>http://zmdada.gitee.io/2020/08/01/uploadtest-1/</id>
    <published>2020-08-01T12:40:58.000Z</published>
    <updated>2020-10-15T13:14:04.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>测试！测试！</p><a id="more"></a><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>测试！测试！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hexo zm站点搭建测试！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;p&gt;测试！测试！&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="http://zmdada.gitee.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="http://zmdada.gitee.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>音乐测试</title>
    <link href="http://zmdada.gitee.io/2020/08/01/uploadtest-4/"/>
    <id>http://zmdada.gitee.io/2020/08/01/uploadtest-4/</id>
    <published>2020-08-01T06:26:42.000Z</published>
    <updated>2020-10-15T13:13:46.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="音乐播放测试"><a href="#音乐播放测试" class="headerlink" title="音乐播放测试"></a>音乐播放测试</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1465814430&auto=1&height=66"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;音乐播放测试&quot;&gt;&lt;a href=&quot;#音乐播放测试&quot; class=&quot;headerlink&quot; title=&quot;音乐播放测试&quot;&gt;&lt;/a&gt;音乐播放测试&lt;/h2&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; margi</summary>
      
    
    
    
    <category term="测试" scheme="http://zmdada.gitee.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="http://zmdada.gitee.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>随笔添加测试</title>
    <link href="http://zmdada.gitee.io/2020/08/01/uploadtest-2/"/>
    <id>http://zmdada.gitee.io/2020/08/01/uploadtest-2/</id>
    <published>2020-08-01T05:08:45.000Z</published>
    <updated>2020-08-01T06:55:08.000Z</updated>
    
    
    
    
    
    <category term="随笔" scheme="http://zmdada.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>markdown书写测试</title>
    <link href="http://zmdada.gitee.io/2020/08/01/uploadtest-3/"/>
    <id>http://zmdada.gitee.io/2020/08/01/uploadtest-3/</id>
    <published>2020-08-01T05:08:45.000Z</published>
    <updated>2020-10-15T13:13:22.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章编写测试"><a href="#文章编写测试" class="headerlink" title="文章编写测试"></a>文章编写测试</h1><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>用#的个数分标题级数<br>使用标题 </p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>同段落编写时两次空格<br>再转行，不同段落空出<br>一整行</p><p>段落1</p><p>段落2</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>文字前加 &gt;</p><blockquote><p>高亮显示内容</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[网址]加（具体地址） </p><p><a href="https://www.baidu.com/">百度</a> </p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>！加[]加（） 括号中为图片地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=365079614,1609633836&fm=26&gp=0.jpg" alt="测试"></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>内容前加 *空格  </p><ul><li>列表1  </li><li>列表2</li><li>列表3<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2>在前面加数字加.空格</li></ul><ol><li>列表1</li><li>列表2</li><li>列表3 <h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2>用多于3条—来表示或者***  </li></ol><hr><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;文章编写测试&quot;&gt;&lt;a href=&quot;#文章编写测试&quot; class=&quot;headerlink&quot; title=&quot;文章编写测试&quot;&gt;&lt;/a&gt;文章编写测试&lt;/h1&gt;</summary>
    
    
    
    <category term="测试" scheme="http://zmdada.gitee.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="http://zmdada.gitee.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>上传测试</title>
    <link href="http://zmdada.gitee.io/2020/07/31/uploadtest/"/>
    <id>http://zmdada.gitee.io/2020/07/31/uploadtest/</id>
    <published>2020-07-31T12:40:58.000Z</published>
    <updated>2020-07-31T15:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>测试！测试！</p><a id="more"></a><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>测试！测试！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hexo zm站点搭建测试！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;p&gt;测试！测试！&lt;/p&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://zmdada.gitee.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
